1. Executive Summary
1.1 Product Vision
A zero-cost, mobile-first Progressive Web App that democratizes access to text-to-speech technology by leveraging native browser APIs. Designed specifically for iOS users who need a Speechify alternative without subscription fees.
1.2 Problem Statement
Current text-to-speech solutions require expensive annual subscriptions ($139/year for Speechify Premium). Users need a free, privacy-focused alternative that works offline and doesn't lock features behind paywalls.
1.3 Target Audience
Primary Users:
	•	Students who need to listen to textbooks, articles, and study materials
	•	Professionals who consume written content during commutes or workouts
	•	Users with reading difficulties (dyslexia, visual impairments, attention disorders)
	•	Content consumers who prefer audio format
User Characteristics:
	•	Own iOS devices (iPhone 14+, iOS 16+)
	•	Comfortable with mobile apps
	•	Value privacy and data ownership
	•	Budget-conscious or prefer free alternatives
1.4 Success Criteria
Quantitative Metrics:
	•	Time to First Speech: <2 seconds from app launch
	•	App Load Time: <1.5 seconds (75th percentile)
	•	Crash-Free Rate: >99.5%
	•	File Import Success Rate: >95% for supported formats
	•	Offline Functionality: 100% after initial cache
Qualitative Metrics:
	•	User can accomplish primary task (read text aloud) without instructions
	•	Zero user-reported data privacy concerns
	•	Positive feedback on voice quality from iOS users
1.5 Out of Scope (v1.0)
	•	Android optimization
	•	Cloud sync/multi-device support
	•	Audio file export (MP3/WAV)
	•	Advanced text editing features
	•	Social sharing features
	•	User accounts/authentication
	•	Analytics tracking
	•	Browser extension

2. User Research & Personas
2.1 Primary Persona: Sarah - Graduate Student
Demographics:
	•	Age: 24
	•	Occupation: Graduate student in Psychology
	•	Device: iPhone 15 Pro
	•	Tech Savviness: High
Goals:
	•	Listen to academic papers while commuting (45 min daily)
	•	Review study materials while doing chores
	•	Save money (no budget for subscriptions)
Pain Points:
	•	Speechify subscription too expensive
	•	Academic PDFs often have complex formatting
	•	Needs to work offline (spotty campus wifi)
	•	Wants to save frequently accessed texts
Use Cases:
	•	Imports PDF research papers and listens during commute
	•	Pastes article text for quick listening
	•	Saves important papers to library for repeated access
	•	Adjusts speed to 1.5x for efficiency
2.2 Secondary Persona: Marcus - Dyslexic Professional
Demographics:
	•	Age: 32
	•	Occupation: Marketing Manager
	•	Device: iPhone 14
	•	Tech Savviness: Medium
Goals:
	•	Read work emails and documents independently
	•	Process written content without fatigue
	•	Maintain professional productivity
Pain Points:
	•	Reading long documents causes eye strain
	•	Takes longer to process written information
	•	Needs high-quality, natural-sounding voices
	•	Privacy concerns about work documents
Use Cases:
	•	Pastes email threads to listen before meetings
	•	Imports work documents (DOCX/PDF)
	•	Uses during work hours (needs reliable, quick access)
	•	Requires clear, natural voice quality

3. Feature Requirements
3.1 Prioritization Framework (MoSCoW)
MUST HAVE (Critical for v1.0)
	•	Text input and playback
	•	High-quality voice selection
	•	Playback controls (play/pause/stop)
	•	Speed adjustment
	•	Text persistence (auto-save)
	•	PWA installation
	•	Offline functionality
SHOULD HAVE (Important but not critical)
	•	File import (.txt, .pdf, .docx)
	•	Text library (save multiple texts)
	•	Reading progress visualization
	•	Current word highlighting
COULD HAVE (Nice to have if time permits)
	•	Skip forward/backward (sentence level)
	•	Pitch adjustment
	•	Search within saved texts
	•	Export saved texts
WON'T HAVE (v1.0)
	•	Cloud synchronization
	•	Audio export
	•	Advanced text editing
	•	User accounts
3.2 Detailed Feature Specifications

F1: Text Input System
Priority: MUST HAVE Complexity: Low Dependencies: None
User Story: As a user, I want to easily input large amounts of text so that I can have it read aloud to me.
Functional Requirements:
FR1.1: Large Text Area
	•	Textarea must occupy minimum 65% of viewport height on mobile
	•	Support for 200,000+ characters without performance degradation
	•	Font size: 16px minimum for readability
	•	Line height: 1.6 for comfortable reading
	•	Monospaced option for code/technical content
FR1.2: Smart Auto-Save
	•	Save to localStorage every 3 seconds when text changes
	•	Debounce saves to prevent excessive writes
	•	Save current cursor position
	•	Restore text and position on app reload
	•	Visual indicator when save completes (subtle, non-intrusive)
FR1.3: Character Management
	•	Real-time character count display
	•	Word count display
	•	Estimated reading time (based on selected speed)
	•	Warning at 150,000 characters (approaching localStorage limits)
	•	Clear text button with confirmation dialog
FR1.4: Mobile Optimizations
	•	One-tap paste button (iOS pasteboard access)
	•	Auto-focus on textarea when app loads
	•	Prevent zoom on focus (viewport meta tag)
	•	Haptic feedback on paste (iOS)
Acceptance Criteria:
	•	User can paste 100,000 characters without lag
	•	Text persists after browser refresh
	•	Character count updates in <100ms
	•	Auto-save indicator appears briefly after save
	•	Clear button shows confirmation before deletion
	•	Paste button works with single tap
	•	No zoom-in when tapping textarea
Technical Specifications:


javascript
// Auto-save implementation
const AUTO_SAVE_DELAY = 3000; // 3 seconds
const MAX_CHARS = 200000;
const WARN_THRESHOLD = 150000;

// Character count calculation
function countWords(text) {
  return text.trim().split(/\s+/).length;
}

function estimateReadingTime(text, wordsPerMinute) {
  const words = countWords(text);
  return Math.ceil(words / wordsPerMinute);
}

F2: Web Speech API Integration
Priority: MUST HAVE Complexity: High Dependencies: None
User Story: As a user, I want high-quality, natural-sounding voices to read my text so that I can comfortably listen for extended periods.
Functional Requirements:
FR2.1: Voice Discovery and Prioritization
	•	Query all available speechSynthesis voices on load
	•	Implement intelligent prioritization algorithm
	•	Filter out low-quality/network voices
	•	Default to highest quality voice automatically
	•	Support for 40+ languages (iOS native support)
Voice Quality Scoring Algorithm:


javascript
function scoreVoice(voice) {
  let score = 0;
  
  // Premium indicators (highest priority)
  if (voice.voiceURI.includes('premium')) score += 100;
  if (voice.voiceURI.includes('enhanced')) score += 80;
  if (voice.voiceURI.includes('natural')) score += 60;
  
  // Apple-specific high-quality voices
  if (voice.voiceURI.includes('com.apple.voice.premium')) score += 100;
  if (voice.voiceURI.includes('com.apple.ttsbundle')) score += 80;
  
  // Prefer local voices over network
  if (voice.localService) score += 50;
  
  // English voice preference for default
  if (voice.lang.startsWith('en-')) score += 20;
  
  // Specific high-quality iOS voices
  const highQualityVoices = ['Samantha', 'Alex', 'Siri'];
  if (highQualityVoices.some(name => voice.name.includes(name))) {
    score += 40;
  }
  
  return score;
}
FR2.2: Text Chunking Strategy
	•	Split text at sentence boundaries (period, exclamation, question mark)
	•	Maximum chunk size: 30,000 characters (safe buffer under 32k limit)
	•	Maintain context across chunks (no mid-sentence breaks)
	•	Track current chunk index for resume functionality
FR2.3: Playback State Management
	•	States: IDLE, PLAYING, PAUSED, STOPPED
	•	Track current position (character index, chunk index)
	•	Maintain position on pause
	•	Reset to beginning on stop
	•	Resume from exact position on play
FR2.4: Boundary Tracking
	•	Use boundary event to track word positions
	•	Calculate character offsets in original text
	•	Enable precise highlighting and progress tracking
	•	Handle chunk transitions seamlessly
Acceptance Criteria:
	•	High-quality iOS voices appear at top of voice list
	•	App defaults to best available voice on first launch
	•	Text longer than 32,000 chars plays without interruption
	•	Pausing and resuming maintains exact position
	•	Voice selection persists across sessions
	•	Playback continues across chunk boundaries smoothly
	•	Boundary events fire for word-level tracking
Technical Specifications:


javascript
class SpeechEngine {
  constructor() {
    this.synth = window.speechSynthesis;
    this.currentUtterance = null;
    this.chunks = [];
    this.currentChunkIndex = 0;
    this.currentCharIndex = 0;
    this.state = 'IDLE';
    this.boundaryCallback = null;
  }
  
  async initialize() {
    // Wait for voices to load (required on iOS)
    return new Promise((resolve) => {
      const voices = this.synth.getVoices();
      if (voices.length) {
        this.voices = this.prioritizeVoices(voices);
        resolve();
      } else {
        this.synth.addEventListener('voiceschanged', () => {
          this.voices = this.prioritizeVoices(this.synth.getVoices());
          resolve();
        });
      }
    });
  }
  
  chunkText(text) {
    const maxChunkSize = 30000;
    const chunks = [];
    const sentences = text.match(/[^.!?]+[.!?]+/g) || [text];
    
    let currentChunk = '';
    for (const sentence of sentences) {
      if (currentChunk.length + sentence.length > maxChunkSize) {
        if (currentChunk) chunks.push(currentChunk);
        currentChunk = sentence;
      } else {
        currentChunk += sentence;
      }
    }
    if (currentChunk) chunks.push(currentChunk);
    
    return chunks;
  }
  
  play(text, startChar = 0) {
    this.chunks = this.chunkText(text);
    this.currentChunkIndex = this.getChunkIndexForChar(startChar);
    this.speakChunk(this.currentChunkIndex);
    this.state = 'PLAYING';
  }
  
  pause() {
    this.synth.pause();
    this.state = 'PAUSED';
  }
  
  resume() {
    this.synth.resume();
    this.state = 'PLAYING';
  }
  
  stop() {
    this.synth.cancel();
    this.state = 'STOPPED';
    this.currentChunkIndex = 0;
    this.currentCharIndex = 0;
  }
}
```

**Error Handling:**
- Network voice unavailable: Fallback to local voice
- Speech synthesis fails: Show error toast, offer retry
- Voice not found: Use default system voice
- Browser doesn't support API: Show clear error message with recommendations

---

#### F3: Playback Controls
**Priority:** MUST HAVE  
**Complexity:** Medium  
**Dependencies:** F2 (Speech Engine)

**User Story:**
As a user, I want intuitive, thumb-friendly controls so that I can easily manage playback while multitasking.

**Functional Requirements:**

**FR3.1: Primary Controls**
- Play/Pause toggle button (single button, changes icon)
- Stop button (returns to beginning)
- Controls always visible (sticky positioning)
- Large touch targets (64x64px minimum)
- Clear visual feedback on press

**FR3.2: Secondary Controls (Optional for v1)**
- Skip forward by sentence
- Skip backward by sentence
- 10-second skip forward/backward

**FR3.3: Control States**
- Disabled state when no text present
- Loading state during file import
- Visual indication of current state (playing/paused)
- Haptic feedback on iOS

**FR3.4: Keyboard Shortcuts (Desktop/iPad)**
- Space: Play/Pause
- Escape: Stop
- Arrow Right: Skip forward
- Arrow Left: Skip backward

**Acceptance Criteria:**
- [ ] Play button starts reading from current position or beginning
- [ ] Pause maintains position precisely
- [ ] Stop resets to beginning and clears highlighting
- [ ] All buttons respond within 100ms
- [ ] Controls remain visible when scrolling
- [ ] Buttons are easily tappable with thumb (bottom 1/3 of screen)
- [ ] Visual feedback appears instantly on press
- [ ] Keyboard shortcuts work on iPad/desktop

**UI Specifications:**
```
Control Layout (Mobile):

[────────────────────────────────────]
[                                    ]
[         Text Area (65vh)           ]
[                                    ]
[────────────────────────────────────]
[  ⏮  ⏯  ⏹  ⏭  ]  ← 64px buttons
[────────────────────────────────────]
[  Progress: 45% | 2:30 / 5:34      ]
[────────────────────────────────────]
```

---

#### F4: Voice Selection
**Priority:** MUST HAVE  
**Complexity:** Medium  
**Dependencies:** F2 (Speech Engine)

**User Story:**
As a user, I want to choose from the best available voices so that I can find one that I find pleasant and easy to understand.

**Functional Requirements:**

**FR4.1: Voice Selector Interface**
- Modal or bottom sheet selection UI
- Scrollable list of available voices
- Voice metadata display: Name, Language, Quality indicator
- Sample playback for each voice (speak sample sentence)
- Search/filter by language
- Recently used voices at top

**FR4.2: Voice Information Display**
```
[Voice Name]  [Quality Badge]
Language: English (United States)
[▶ Preview]
Quality Badges:
	•	"Premium" - Highest quality iOS voices
	•	"Enhanced" - High quality voices
	•	"Standard" - Basic quality voices
FR4.3: Voice Persistence
	•	Save selected voice ID to localStorage
	•	Restore on app launch
	•	Fallback to best available if saved voice not found
FR4.4: Voice Preview
	•	Play 2-3 second sample: "Hello, this is how I sound."
	•	Stop current preview when new one starts
	•	Same speed/pitch settings as main playback
Acceptance Criteria:
	•	All available voices appear in selector
	•	Premium iOS voices clearly marked and listed first
	•	Preview plays immediately on tap
	•	Selected voice persists across sessions
	•	If saved voice unavailable, selects next best automatically
	•	Can filter by language easily
	•	Search works for voice name and language
Technical Specifications:


javascript
const SAMPLE_TEXT = "Hello, this is a preview of how I sound when reading your text.";

function getVoiceQuality(voice) {
  const uri = voice.voiceURI.toLowerCase();
  if (uri.includes('premium')) return 'premium';
  if (uri.includes('enhanced') || uri.includes('natural')) return 'enhanced';
  return 'standard';
}

function groupVoicesByLanguage(voices) {
  return voices.reduce((groups, voice) => {
    const lang = voice.lang;
    if (!groups[lang]) groups[lang] = [];
    groups[lang].push(voice);
    return groups;
  }, {});
}
```

---

#### F5: Speed Control
**Priority:** MUST HAVE  
**Complexity:** Low  
**Dependencies:** F2 (Speech Engine)

**User Story:**
As a user, I want to adjust playback speed so that I can listen at my preferred pace.

**Functional Requirements:**

**FR5.1: Speed Range and Increments**
- Minimum: 0.5x (50% speed)
- Maximum: 2.5x (250% speed)
- Default: 1.0x (100% speed)
- Increment: 0.1x
- Presets: 0.5x, 0.75x, 1.0x, 1.25x, 1.5x, 1.75x, 2.0x, 2.5x

**FR5.2: Speed Control Interface**
- Slider for continuous adjustment
- Preset buttons for common speeds
- Current speed display (e.g., "1.5x")
- Live adjustment (changes speed immediately during playback)

**FR5.3: Speed Persistence**
- Save speed preference to localStorage
- Restore on app launch
- Maintain across different texts

**Acceptance Criteria:**
- [ ] Speed changes apply immediately during playback
- [ ] No audio glitches when changing speed
- [ ] Speed value displays clearly
- [ ] Slider is easy to adjust with thumb
- [ ] Preset buttons provide quick access to common speeds
- [ ] Speed persists across sessions
- [ ] Speed setting applies to voice previews as well

**UI Specifications:**
```
Speed Control UI:

Speed: [1.5x]
[━━━━━●━━━━━━] 0.5x ──── 2.5x

Quick Presets:
[0.5x] [1.0x] [1.5x] [2.0x]

F6: Reading Progress Tracking
Priority: SHOULD HAVE Complexity: Medium Dependencies: F2 (Speech Engine)
User Story: As a user, I want to see my progress through the text so that I know how much remains and can track my position.
Functional Requirements:
FR6.1: Visual Progress Indicators
	•	Progress bar showing percentage complete
	•	Time display: "2:30 / 5:34" (current / total)
	•	Percentage display: "45%"
	•	Progress bar is tappable to seek to position
FR6.2: Current Word Highlighting
	•	Highlight current word being spoken
	•	Use blue semi-transparent background
	•	Auto-scroll to keep highlighted word in view
	•	Smooth scrolling animation
FR6.3: Progress Calculation
	•	Calculate based on character position
	•	Estimate total time based on text length and speed
	•	Update every 500ms during playback
	•	Account for pauses and speed changes
FR6.4: Seek Functionality (Optional for v1)
	•	Tap progress bar to jump to position
	•	Visual preview of where tap will land
	•	Sentence-level granularity (don't break mid-word)
Acceptance Criteria:
	•	Progress bar updates smoothly during playback
	•	Time remaining accurate within 5 seconds
	•	Current word highlights with blue background
	•	Auto-scroll keeps highlighted word in center 1/3 of viewport
	•	Progress persists on pause
	•	Seeking works and jumps to correct position
	•	No jank or performance issues during highlighting
Technical Specifications:


javascript
function calculateProgress(currentChar, totalChars) {
  return Math.min(100, (currentChar / totalChars) * 100);
}

function estimateTimeRemaining(remainingChars, speed, avgCharsPerSecond) {
  const baseCharsPerSecond = 15; // ~180 WPM average
  const adjustedSpeed = baseCharsPerSecond * speed;
  return Math.ceil(remainingChars / adjustedSpeed);
}

function formatTime(seconds) {
  const mins = Math.floor(seconds / 60);
  const secs = seconds % 60;
  return `${mins}:${secs.toString().padStart(2, '0')}`;
}

// Highlighting implementation
function highlightWord(text, startChar, length) {
  // Calculate word boundaries
  const before = text.substring(0, startChar);
  const word = text.substring(startChar, startChar + length);
  const after = text.substring(startChar + length);
  
  // Return wrapped HTML
  return `${before}<span class="highlight">${word}</span>${after}`;
}

// Auto-scroll implementation
function scrollToHighlight() {
  const highlighted = document.querySelector('.highlight');
  if (!highlighted) return;
  
  const rect = highlighted.getBoundingClientRect();
  const viewportHeight = window.innerHeight;
  const targetPosition = rect.top - (viewportHeight / 3);
  
  window.scrollTo({
    top: window.scrollY + targetPosition,
    behavior: 'smooth'
  });
}
```

---

#### F7: Text Library
**Priority:** SHOULD HAVE  
**Complexity:** Medium  
**Dependencies:** F1 (Text Input)

**User Story:**
As a user, I want to save frequently accessed texts so that I can quickly load them without re-importing or re-pasting.

**Functional Requirements:**

**FR7.1: Library Storage**
- Save up to 50 texts in localStorage
- Each entry stores:
  - Unique ID (UUID)
  - Title (user-editable, max 100 chars)
  - Content (full text, up to 200k chars)
  - Date created (timestamp)
  - Date last modified (timestamp)
  - Character count
  - Word count
  - Last read position (optional)

**FR7.2: Library Interface**
- Grid/list view of saved texts
- Each card shows:
  - Title (truncated if needed)
  - First 100 characters of content (preview)
  - Character/word count
  - Date created/modified
  - Actions: Load, Rename, Delete
- Search/filter functionality
- Sort by: Date Created, Date Modified, Title (A-Z), Size

**FR7.3: Save Operations**
- "Save" button in main interface
- Auto-generate title from first 50 characters
- Allow custom title entry
- Prevent duplicate saves (warn if similar title exists)
- Show confirmation: "Saved to library"

**FR7.4: Load Operations**
- Tap to load text into main editor
- Warn if unsaved changes in current text
- Load preserves formatting
- Restore last read position (optional)

**FR7.5: Delete Operations**
- Swipe-to-delete on iOS
- Delete button with confirmation dialog
- Confirmation shows text title and preview
- Bulk delete option (select multiple)

**FR7.6: Storage Management**
- Monitor localStorage usage
- Warn at 80% capacity
- Show storage usage in settings
- LRU eviction when full (remove least recently accessed)

**Acceptance Criteria:**
- [ ] Can save current text with one tap
- [ ] Saved texts appear in library immediately
- [ ] Can search by title or content
- [ ] Loading text from library is instant (<500ms)
- [ ] Delete requires confirmation
- [ ] Storage warning appears before hitting limit
- [ ] Library handles 50 texts without lag
- [ ] Sorting and filtering work correctly

**UI Specifications:**
```
Library View:

[Search: ________]  [Sort: Date ▼]

┌──────────────────────────────────┐
│ Research Paper on Cognition      │
│ In recent studies of cognitive...│
│ 45,230 chars | Jan 15, 2025     │
│ [Load] [Rename] [Delete]         │
└──────────────────────────────────┘

┌──────────────────────────────────┐
│ Article: Future of AI            │
│ The rapid advancement of artif...│
│ 12,450 chars | Jan 14, 2025     │
│ [Load] [Rename] [Delete]         │
└──────────────────────────────────┘
Storage Schema:


javascript
{
  savedTexts: [
    {
      id: "uuid-v4",
      title: "Research Paper on Cognition",
      content: "Full text content...",
      created: 1705334400000,
      modified: 1705334400000,
      charCount: 45230,
      wordCount: 7538,
      lastPosition: 12450 // optional
    }
  ]
}

F8: File Import
Priority: SHOULD HAVE Complexity: High Dependencies: External libraries (PDF.js, Mammoth.js)
User Story: As a user, I want to import documents so that I can listen to content without manually copying and pasting.
Functional Requirements:
FR8.1: Supported File Types
	•	Plain text (.txt) - Native support
	•	PDF documents (.pdf) - Via PDF.js
	•	Word documents (.docx) - Via Mammoth.js
	•	Maximum file size: 10MB
	•	Maximum extracted text: 200,000 characters
FR8.2: Import Interface
	•	Large "Import File" button in main interface
	•	System file picker integration
	•	Drag-and-drop support (iPad/desktop)
	•	Multiple file selection (processes sequentially)
FR8.3: Import Processing
	•	Show loading indicator with progress
	•	Display processing status: "Extracting text from PDF..."
	•	Cancel option during long operations
	•	Error handling with specific messages
FR8.4: Text Extraction
.txt Files:
	•	Read directly with FileReader API
	•	Preserve line breaks
	•	Handle different encodings (UTF-8, UTF-16)
.pdf Files (PDF.js):
	•	Extract text from all pages
	•	Preserve paragraph structure
	•	Ignore images, tables, headers/footers
	•	Handle scanned PDFs (show error, suggest OCR tools)
	•	Progress indicator per page
.docx Files (Mammoth.js):
	•	Extract body text only
	•	Preserve paragraphs and line breaks
	•	Ignore formatting, images, headers/footers
	•	Handle bullet lists (convert to plain text)
FR8.5: Post-Import Actions
	•	Load extracted text into main editor
	•	Show character/word count
	•	Offer to save to library immediately
	•	Preserve filename as suggested title
FR8.6: Error Handling
	•	File too large: "File exceeds 10MB limit"
	•	Unsupported format: "File type not supported. Use .txt, .pdf, or .docx"
	•	Corrupted file: "Unable to read file. File may be corrupted."
	•	Extraction failed: "Could not extract text. Try another file."
	•	Scanned PDF: "This appears to be a scanned PDF. Text extraction not possible."
Acceptance Criteria:
	•	Can import .txt files successfully
	•	Can import .pdf files and extract text accurately
	•	Can import .docx files and extract text accurately
	•	Processing 1MB file takes <5 seconds
	•	Progress indicator shows during processing
	•	Error messages are clear and actionable
	•	Can cancel long-running imports
	•	Extracted text loads into editor correctly
	•	Multiple file imports work sequentially
Technical Specifications:
PDF.js Configuration:


javascript
// Load PDF.js from CDN
pdfjsLib.GlobalWorkerOptions.workerSrc = 
  'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';

async function extractPDFText(file) {
  const arrayBuffer = await file.arrayBuffer();
  const loadingTask = pdfjsLib.getDocument({ data: arrayBuffer });
  const pdf = await loadingTask.promise;
  
  let fullText = '';
  const totalPages = pdf.numPages;
  
  for (let i = 1; i <= totalPages; i++) {
    // Update progress: i / totalPages
    const page = await pdf.getPage(i);
    const textContent = await page.getTextContent();
    const pageText = textContent.items
      .map(item => item.str)
      .join(' ');
    fullText += pageText + '\n\n';
  }
  
  return fullText.trim();
}
Mammoth.js Configuration:


javascript
async function extractDOCXText(file) {
  const arrayBuffer = await file.arrayBuffer();
  const result = await mammoth.extractRawText({ arrayBuffer });
  
  if (result.messages.length > 0) {
    console.warn('DOCX extraction warnings:', result.messages);
  }
  
  return result.value;
}
File Validation:


javascript
const MAX_FILE_SIZE = 10 * 1024 * 1024; // 10MB
const SUPPORTED_TYPES = {
  'text/plain': 'txt',
  'application/pdf': 'pdf',
  'application/vnd.openxmlformats-officedocument.wordprocessingml.document': 'docx'
};

function validateFile(file) {
  if (file.size > MAX_FILE_SIZE) {
    throw new Error('File size exceeds 10MB limit');
  }
  
  if (!SUPPORTED_TYPES[file.type]) {
    throw new Error(`Unsupported file type: ${file.type}`);
  }
  
  return true;
}
Performance Requirements:
	•	1MB .txt file: <500ms
	•	1MB .pdf file (10 pages): <3 seconds
	•	1MB .docx file: <2 seconds
	•	10MB files: <30 seconds with progress updates every 500ms

F9: Progressive Web App (PWA)
Priority: MUST HAVE Complexity: Medium Dependencies: None
User Story: As a user, I want to install the app on my home screen and use it offline so that it feels like a native app.
Functional Requirements:
FR9.1: Installation
	•	Web app manifest with proper metadata
	•	Install prompt on iOS Safari (Add to Home Screen)
	•	App icon (192x192, 512x512)
	•	Splash screen
	•	Standalone display mode (no browser UI)
FR9.2: Offline Functionality
	•	Service worker caches all app assets
	•	App shell loads instantly offline
	•	localStorage data available offline
	•	Speech API works offline (uses local voices)
	•	File import works offline (once libraries cached)
FR9.3: App Metadata
	•	Name: "Text Reader"
	•	Short name: "TTS Reader"
	•	Description: "Free text-to-speech reader"
	•	Theme color: #1E1E1E (dark)
	•	Background color: #1E1E1E
	•	Start URL: /
	•	Display: standalone
	•	Orientation: portrait (prefer) but support landscape
FR9.4: Service Worker Strategy
	•	Cache-first for app assets (HTML, CSS, JS)
	•	Network-first for external libraries (PDF.js, Mammoth.js)
	•	No caching for user data (always use localStorage)
	•	Cache version management for updates
Acceptance Criteria:
	•	Install prompt appears in iOS Safari
	•	App icon appears on home screen
	•	App opens without Safari UI
	•	App works completely offline after first load
	•	Service worker updates don't break app
	•	Splash screen shows during load
Technical Specifications:
manifest.json:


json
{
  "name": "Text Reader",
  "short_name": "TTS Reader",
  "description": "Free text-to-speech reader with file import",
  "start_url": "/",
  "display": "standalone",
  "orientation": "portrait",
  "background_color": "#1E1E1E",
  "theme_color": "#1E1E1E",
  "icons": [
    {
      "src": "/icons/icon-192.png",
      "sizes": "192x192",
      "type": "image/png",
      "purpose": "any maskable"
    },
    {
      "src": "/icons/icon-512.png",
      "sizes": "512x512",
      "type": "image/png",
      "purpose": "any maskable"
    }
  ]
}
Service Worker:


javascript
const CACHE_VERSION = 'v1.0.0';
const CACHE_NAME = `tts-reader-${CACHE_VERSION}`;

const STATIC_ASSETS = [
  '/',
  '/index.html',
  '/css/styles.css',
  '/js/app.js',
  '/js/speech.js',
  '/js/storage.js',
  '/js/ui.js',
  '/js/fileImport.js',
  '/manifest.json',
  '/icons/icon-192.png',
  '/icons/icon-512.png'
];

// Install: cache static assets
self.addEventListener('install', (event) => {
  event.waitUntil(
    caches.open(CACHE_NAME)
      .then(cache => cache.addAll(STATIC_ASSETS))
      .then(() => self.skipWaiting())
  );
});

// Activate: clean up old caches
self.addEventListener('activate', (event) => {
  event.waitUntil(
    caches.keys()
      .then(keys => Promise.all(
        keys.map(key => {
          if (key !== CACHE_NAME) {
            return caches.delete(key);
          }
        })
      ))
      .then(() => self.clients.claim())
  );
});

// Fetch: cache-first for static, network-first for external
self.addEventListener('fetch', (event) => {
  const { request } = event;
  
  // Cache strategy for static assets
  if (STATIC_ASSETS.includes(new URL(request.url).pathname)) {
    event.respondWith(
      caches.match(request)
        .then(response => response || fetch(request))
    );
  } 
  // Network-first for external resources
  else {
    event.respondWith(
      fetch(request)
        .catch(() => caches.match(request))
    );
  }
});
```

---

## 4. Non-Functional Requirements

### 4.1 Performance

**Load Time:**
- First Contentful Paint: <1 second
- Time to Interactive: <2 seconds
- Largest Contentful Paint: <2.5 seconds

**Runtime Performance:**
- Maintain 60 FPS scrolling
- Text input response: <100ms
- Speech start latency: <1 second
- File import (1MB): <5 seconds

**Memory:**
- Peak memory usage: <150MB
- No memory leaks during extended playback
- Efficient garbage collection

**Storage:**
- Maximum localStorage usage: 50MB
- Efficient data serialization
- Graceful degradation at capacity

### 4.2 Reliability

**Availability:**
- 100% uptime (static hosting, no backend)
- Works offline after first load
- Graceful handling of network errors

**Error Recovery:**
- Auto-save prevents data loss
- Clear error messages with recovery steps
- No silent failures

**Data Integrity:**
- No data corruption in localStorage
- Atomic save operations
- Backup/export functionality

### 4.3 Security

**Data Privacy:**
- No data sent to external servers
- No analytics or tracking
- No cookies (except essential localStorage)
- No third-party scripts (except CDN libraries)

**Content Security:**
- Content Security Policy headers
- Prevent XSS attacks
- Sanitize user input

**File Upload Security:**
- File type validation
- File size limits
- Safe file parsing (no code execution)

### 4.4 Accessibility

**WCAG 2.1 Level AA Compliance:**
- All interactive elements keyboard accessible
- Proper ARIA labels
- Sufficient color contrast (7:1 minimum for text)
- Touch targets ≥44x44px
- Screen reader support
- Reduced motion support

**Semantic HTML:**
- Proper heading hierarchy
- Meaningful alt text
- Form labels and descriptions

### 4.5 Compatibility

**Browsers:**
- iOS Safari 16+ (primary)
- iOS Chrome 110+ (secondary)
- iPad Safari 16+
- Graceful degradation for older browsers

**Devices:**
- iPhone 12 and newer (primary)
- iPad Pro (secondary)
- Screen sizes: 375px - 1024px width

**Operating Systems:**
- iOS 16+
- iPadOS 16+

### 4.6 Usability

**Learnability:**
- Core function usable without instructions
- Clear visual hierarchy
- Intuitive iconography
- Helpful empty states

**Efficiency:**
- Minimal taps to complete tasks
- Smart defaults reduce configuration
- Keyboard shortcuts for power users

**Memorability:**
- Consistent UI patterns
- Persistent state (settings, position)
- Familiar mobile interactions

### 4.7 Maintainability

**Code Quality:**
- ESLint compliant
- Comprehensive comments
- Modular architecture
- Unit test coverage >80%

**Documentation:**
- README with setup instructions
- Inline code documentation
- API documentation for modules

**Versioning:**
- Semantic versioning
- Changelog maintenance
- Migration guides for breaking changes

---

## 5. Technical Constraints

### 5.1 Web Speech API Limitations

**Character Limits:**
- Max utterance length: ~32,000 characters (browser dependent)
- Solution: Intelligent text chunking

**Voice Availability:**
- Voice quality varies by device
- Some voices require internet connection
- Solution: Prioritize local, high-quality voices

**Browser Support:**
- Limited to Chromium and Safari
- No Firefox support
- Solution: Detect and show compatibility message

### 5.2 Storage Limitations

**localStorage:**
- Quota: 5-10MB (browser dependent)
- Synchronous API (can block main thread)
- No encryption
- Solution: Monitor usage, warn users, compress data

**IndexedDB (Future):**
- Consider for v2.0 if more storage needed

### 5.3 iOS Specific Constraints

**Audio Playback:**
- Requires user gesture to start
- May pause when app backgrounds
- Solution: Clear UI indicating user action needed

**File System Access:**
- No direct file system access
- Relies on file picker
- Solution: Use native file picker API

**Service Workers:**
- Limited support compared to Android
- Solution: Progressive enhancement

---

## 6. Risk Assessment

### High Risk

**R1: Web Speech API Browser Support**
- **Risk:** API not available or limited in user's browser
- **Impact:** Core functionality unavailable
- **Mitigation:** Feature detection, clear error message, graceful degradation
- **Contingency:** Link to compatible browsers

**R2: Voice Quality Variance**
- **Risk:** Low-quality voices on some devices
- **Impact:** Poor user experience
- **Mitigation:** Smart voice prioritization, clear quality indicators
- **Contingency:** User education on voice selection

**R3: localStorage Quota**
- **Risk:** Users hit storage limits with large texts
- **Impact:** Cannot save more texts, poor UX
- **Mitigation:** Storage monitoring, warnings, LRU eviction
- **Contingency:** Export functionality to save texts externally

### Medium Risk

**R4: PDF Extraction Accuracy**
- **Risk:** Complex PDFs don't extract well
- **Impact:** Unusable text output
- **Mitigation:** Warn about scanned PDFs, handle errors gracefully
- **Contingency:** Manual copy-paste alternative

**R5: Performance on Older Devices**
- **Risk:** Lag on older iPhones
- **Impact:** Poor user experience
- **Mitigation:** Target iPhone 12+, optimize code, lazy loading
- **Contingency:** Reduce features on detection of older devices

### Low Risk

**R6: Service Worker Updates**
- **Risk:** App doesn't update properly
- **Impact:** Users stuck on old version
- **Mitigation:** Proper cache versioning, update notifications
- **Contingency:** Hard refresh instructions

---

## 7. Success Metrics & KPIs

### Primary Metrics

**Adoption:**
- PWA installations: Target 40% of unique visitors
- Return rate: Target 60% within 7 days

**Engagement:**
- Average session duration: Target 15+ minutes
- Texts read per session: Target 2+
- File imports per user: Target 1+ per week

**Performance:**
- Time to first speech: Target <2 seconds, 90th percentile
- Speech start success rate: Target >98%
- File import success rate: Target >95%

**Quality:**
- Crash-free rate: Target >99.5%
- Error rate: Target <1%

### Secondary Metrics

**Feature Usage:**
- Voice selection: % of users who change default
- Speed adjustment: % of users who adjust speed
- Library saves: Average texts saved per user
- File imports: Distribution by file type

**User Satisfaction:**
- Net Promoter Score (NPS): Target >50
- Task completion rate: Target >95%
- User feedback sentiment: Target >80% positive

---

## 8. Launch Criteria

### Must Have (Blocking)
- [ ] Core text-to-speech works on iOS Safari
- [ ] High-quality voice selection
- [ ] Play/pause/stop controls functional
- [ ] Speed adjustment works
- [ ] Auto-save prevents data loss
- [ ] PWA installable
- [ ] Works offline
- [ ] Zero critical bugs
- [ ] Performance targets met (load <2s, speech <1s)
- [ ] Security review passed

### Should Have (Non-blocking)
- [ ] File import (.txt, .pdf, .docx)
- [ ] Text library (save/load)
- [ ] Reading progress and highlighting
- [ ] All UI polished and accessible
- [ ] Error handling comprehensive

### Could Have (Optional)
- [ ] Skip forward/backward
- [ ] Pitch adjustment
- [ ] Search in library
- [ ] Export saved texts

---

## 9. Future Roadmap (Post v1.0)

### v1.1 (Next 3 Months)
- Background playback support
- Audio export (MP3)
- Bookmarks within texts
- Reading statistics dashboard

### v1.2 (6 Months)
- Cloud sync (optional, paid tier)
- Collaborative text sharing
- OCR for scanned PDFs
- Voice cloning integration

### v2.0 (12 Months)
- Android optimization
- Browser extension
- API for third-party integrations
- Premium voices marketplace

---

## 10. Appendix

### A. Competitive Analysis

**Speechify:**
- Pros: High-quality voices, OCR support, cross-platform
- Cons: $139/year, requires account, cloud dependency
- Our Advantage: Free, privacy-focused, works offline

**Natural Reader:**
- Pros: Web-based, free tier available
- Cons: Limited free tier, dated UI, ads
- Our Advantage: No ads, modern UI, unlimited usage

**Voice Dream Reader:**
- Pros: Excellent iOS app, one-time purchase
- Cons: $15 upfront, iOS only
- Our Advantage: Free, web-based (cross-platform potential)

### B. User Testing Plan

**Phase 1: Alpha (Internal)**
- 5 internal testers
- Focus on core functionality
- Duration: 1 week

**Phase 2: Beta (External)**
- 20-30 iOS users
- Diverse personas (students, professionals, accessibility users)
- Duration: 2 weeks
- Collect: Bug reports, feature requests, usability feedback

**Phase 3: Soft Launch**
- Limited release (invite only)
- Monitor metrics closely
- Duration: 1 month

### C. Legal & Compliance

**Open Source Licenses:**
- PDF.js: Apache License 2.0
- Mammoth.js: BSD 2-Clause License
- Ensure proper attribution

**Privacy Policy:**
- Clear statement: No data collection
- localStorage usage disclosure
- No cookies or tracking

**Terms of Service:**
- Free use, no warranty
- Content responsibility with users
- Proper use guidelines

### D. Support & Documentation

**User Documentation:**
- Getting started guide
- FAQ
- Troubleshooting common issues
- Keyboard shortcuts reference

**Developer Documentation:**
- Setup instructions
- Architecture overview
- Contributing guidelines
- API documentation

---

## Document History

| Version | Date | Author | Changes |
|---------|------|--------|---------|
| 2.0 | Jan 2025 | Product Team | Complete rewrite with detailed specifications |
| 1.0 | Jan 2025 | Product Team | Initial draft |

---

**Approval:**

This PRD requires approval from:
- [ ] Product Manager
- [ ] Engineering Lead
- [ ] Design Lead
- [ ] QA Lead
</artifact>

<artifact identifier="tts-app-trd-v2" type="text/markdown" title="Technical Requirements Document v2">
# Text-to-Speech Reader App
## Technical Requirements Document (TRD) v2.0

---

## 1. System Architecture

### 1.1 High-Level Architecture
```
┌─────────────────────────────────────────────────────────────┐
│                         User Device                          │
│  ┌───────────────────────────────────────────────────────┐  │
│  │                    iOS Safari/Chrome                   │  │
│  │  ┌─────────────────────────────────────────────────┐  │  │
│  │  │            Progressive Web App (PWA)             │  │  │
│  │  │                                                  │  │  │
│  │  │  ┌──────────────┐  ┌──────────────┐           │  │  │
│  │  │  │  UI Layer    │  │ Service      │           │  │  │
│  │  │  │  (Views)     │  │ Worker       │           │  │  │
│  │  │  └──────┬───────┘  └──────┬───────┘           │  │  │
│  │  │         │                   │                   │  │  │
│  │  │  ┌──────▼───────────────────▼───────┐          │  │  │
│  │  │  │     Application Core              │          │  │  │
│  │  │  │  ┌──────────┐  ┌──────────┐      │          │  │  │
│  │  │  │  │ State    │  │ Events   │      │          │  │  │
│  │  │  │  │ Manager  │  │ Bus      │      │          │  │  │
│  │  │  │  └──────────┘  └──────────┘      │          │  │  │
│  │  │  └───────────────────────────────────┘          │  │  │
│  │  │         │                   │                   │  │  │
│  │  │  ┌──────▼──────┐   ┌───────▼────────┐          │  │  │
│  │  │  │   Modules   │   │   Browser APIs  │          │  │  │
│  │  │  │             │   │                 │          │  │  │
│  │  │  │ • Speech    │   │ • Web Speech   │          │  │  │
│  │  │  │ • Storage   │   │ • LocalStorage │          │  │  │
│  │  │  │ • FileImport│   │ • File API     │          │  │  │
│  │  │  │ • UI        │   │ • Vibration    │          │  │  │
│  │  │  └─────────────┘   └────────────────┘          │  │  │
│  │  │         │                                        │  │  │
│  │  │  ┌──────▼─────────────────────────┐            │  │  │
│  │  │  │    External Libraries           │            │  │  │
│  │  │  │  • PDF.js (CDN)                │            │  │  │
│  │  │  │  • Mammoth.js (CDN)            │            │  │  │
│  │  │  └────────────────────────────────┘            │  │  │
│  │  └───────────────────────────────────────────────┘  │  │
│  └──────────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────┘
```

### 1.2 Component Architecture

#### Core Modules

**Application Core (`app.js`)**
- Initialization and bootstrapping
- Module coordination
- Global error handling
- Lifecycle management

**Speech Engine (`speech.js`)**
- Web Speech API wrapper
- Voice management
- Text chunking
- Playback state machine
- Boundary event handling

**Storage Manager (`storage.js`)**
- localStorage abstraction
- Data serialization/deserialization
- Quota monitoring
- Error recovery

**File Import Manager (`fileImport.js`)**
- File validation
- Format detection
- Text extraction orchestration
- Progress tracking

**UI Manager (`ui.js`)**
- DOM manipulation
- View state management
- Event delegation
- Animation coordination

**State Manager (`state.js`)**
- Centralized application state
- State mutations
- Reactive updates
- State persistence

**Event Bus (`events.js`)**
- Decoupled communication
- Custom event system
- Error propagation

---

## 2. Detailed Technical Specifications

### 2.1 Speech Engine Implementation

#### State Machine
```
States: IDLE, LOADING, PLAYING, PAUSED, STOPPED, ERROR

Transitions:
  IDLE -> LOADING: initialize()
  LOADING -> IDLE: onVoicesLoaded()
  IDLE -> PLAYING: play()
  PLAYING -> PAUSED: pause()
  PAUSED -> PLAYING: resume()
  PLAYING/PAUSED -> STOPPED: stop()
  * -> ERROR: onError()
  ERROR -> IDLE: reset()
Speech Engine Class


javascript
/**
 * SpeechEngine - Manages text-to-speech functionality
 * 
 * Responsibilities:
 * - Voice discovery and prioritization
 * - Text chunking for long content
 * - Playback state management
 * - Boundary event tracking
 * - Error handling and recovery
 */
class SpeechEngine {
  constructor() {
    this.synth = window.speechSynthesis;
    this.voices = [];
    this.currentVoice = null;
    this.currentUtterance = null;
    this.state = 'IDLE';
    
    // Text processing
    this.chunks = [];
    this.currentChunkIndex = 0;
    this.currentCharIndex = 0;
    this.fullText = '';
    
    // Playback settings
    this.rate = 1.0;
    this.pitch = 1.0;
    this.volume = 1.0;
    
    // Event callbacks
    this.callbacks = {
      onBoundary: null,
      onEnd: null,
      onError: null,
      onPause: null,
      onResume: null,
      onStart: null
    };
    
    // Performance tracking
    this.metrics = {
      initTime: 0,
      voiceLoadTime: 0,
      chunkProcessingTime: []
    };
  }
  
  /**
   * Initialize speech engine and load voices
   * @returns {Promise<void>}
   */
  async initialize() {
    const startTime = performance.now();
    this.state = 'LOADING';
    
    return new Promise((resolve, reject) => {
      // iOS requires waiting for voiceschanged event
      const voices = this.synth.getVoices();
      
      if (voices.length > 0) {
        this._processVoices(voices);
        this.metrics.initTime = performance.now() - startTime;
        this.state = 'IDLE';
        resolve();
      } else {
        const voiceHandler = () => {
          const voices = this.synth.getVoices();
          if (voices.length > 0) {
            this._processVoices(voices);
            this.metrics.initTime = performance.now() - startTime;
            this.state = 'IDLE';
            this.synth.removeEventListener('voiceschanged', voiceHandler);
            resolve();
          }
        };
        
        this.synth.addEventListener('voiceschanged', voiceHandler);
        
        // Timeout after 10 seconds
        setTimeout(() => {
          if (this.voices.length === 0) {
            this.synth.removeEventListener('voiceschanged', voiceHandler);
            reject(new Error('Voice loading timeout'));
          }
        }, 10000);
      }
    });
  }
  
  /**
   * Process and prioritize voices
   * @private
   */
  _processVoices(voices) {
    const voiceLoadStart = performance.now();
    
    // Filter out network voices (prefer local)
    const localVoices = voices.filter(v => v.localService);
    
    // Score and sort voices
    this.voices = localVoices
      .map(voice => ({
        voice,
        score: this._scoreVoice(voice)
      }))
      .sort((a, b) => b.score - a.score)
      .map(item => item.voice);
    
    // Set default voice (highest scored)
    if (this.voices.length > 0) {
      this.currentVoice = this.voices[0];
    }
    
    this.metrics.voiceLoadTime = performance.now() - voiceLoadStart;
  }
  
  /**
   * Score voice quality for prioritization
   * @private
   */
  _scoreVoice(voice) {
    let score = 0;
    const uri = voice.voiceURI.toLowerCase();
    const name = voice.name.toLowerCase();
    
    // Premium indicators
    if (uri.includes('premium') || name.includes('premium')) score += 100;
    if (uri.includes('enhanced') || name.includes('enhanced')) score += 80;
    if (uri.includes('natural') || name.includes('natural')) score += 60;
    
    // Apple-specific high-quality voice patterns
    if (uri.includes('com.apple.voice.premium')) score += 100;
    if (uri.includes('com.apple.ttsbundle.')) score += 80;
    if (uri.includes('com.apple.eloquence')) score += 40;
    
    // Prefer local over network
    if (voice.localService) score += 50;
    
    // Language preference (prioritize English for default)
    if (voice.lang.startsWith('en-US')) score += 30;
    else if (voice.lang.startsWith('en-')) score += 20;
    
    // Specific high-quality voice names
    const premiumNames = ['samantha', 'alex', 'siri', 'karen', 'daniel'];
    if (premiumNames.some(name => voice.name.toLowerCase().includes(name))) {
      score += 40;
    }
    
    return score;
  }
  
  /**
   * Chunk text into manageable pieces
   * @private
   */
  _chunkText(text) {
    const MAX_CHUNK_SIZE = 30000; // Safe buffer under 32k limit
    const chunks = [];
    
    // Split by sentences first
    const sentenceRegex = /[^.!?]+[.!?]+/g;
    const sentences = text.match(sentenceRegex) || [text];
    
    let currentChunk = '';
    let currentChunkStart = 0;
    
    for (let i = 0; i < sentences.length; i++) {
      const sentence = sentences[i];
      
      // If adding this sentence exceeds limit, save current chunk
      if (currentChunk.length + sentence.length > MAX_CHUNK_SIZE) {
        if (currentChunk.length > 0) {
          chunks.push({
            text: currentChunk,
            startIndex: currentChunkStart
          });
          currentChunkStart += currentChunk.length;
        }
        
        // Handle sentences longer than MAX_CHUNK_SIZE
        if (sentence.length > MAX_CHUNK_SIZE) {
          // Split by words
          const words = sentence.split(/\s+/);
          let wordChunk = '';
          
          for (const word of words) {
            if (wordChunk.length + word.length + 1 > MAX_CHUNK_SIZE) {
              chunks.push({
                text: wordChunk,
                startIndex: currentChunkStart
              });
              currentChunkStart += wordChunk.length;
              wordChunk = word;
            } else {
              wordChunk += (wordChunk ? ' ' : '') + word;
            }
          }
          
          currentChunk = wordChunk;
        } else {
          currentChunk = sentence;
        }
      } else {
        currentChunk += sentence;
      }
    }
    
    // Add final chunk
    if (currentChunk.length > 0) {
      chunks.push({
        text: currentChunk,
        startIndex: currentChunkStart
      });
    }
    
    return chunks;
  }
  
  /**
   * Create utterance with event handlers
   * @private
   */
  _createUtterance(text, chunkIndex, chunkStartIndex) {
    const utterance = new SpeechSynthesisUtterance(text);
    
    utterance.voice = this.currentVoice;
    utterance.rate = this.rate;
    utterance.pitch = this.pitch;
    utterance.volume = this.volume;
    
    // Boundary event for word-level tracking
    utterance.addEventListener('boundary', (event) => {
      if (event.name === 'word') {
        const globalCharIndex = chunkStartIndex + event.charIndex;
        this.currentCharIndex = globalCharIndex;
        
        if (this.callbacks.onBoundary) {
          this.callbacks.onBoundary({
            charIndex: globalCharIndex,
            charLength: event.charLength,
            text: this.fullText
          });
        }
      }
    });
    
    // End event - play next chunk or finish
    utterance.addEventListener('end', () => {
      if (this.state !== 'PLAYING') return;
      
      this.currentChunkIndex++;
      
      if (this.currentChunkIndex < this.chunks.length) {
        // Play next chunk
        this._playChunk(this.currentChunkIndex);
      } else {
        // Finished all chunks
        this.state = 'IDLE';
        this.currentChunkIndex = 0;
        this.currentCharIndex = 0;
        
        if (this.callbacks.onEnd) {
          this.callbacks.onEnd();
        }
      }
    });
    
    // Error handling
    utterance.addEventListener('error', (event) => {
      console.error('Speech synthesis error:', event);
      this.state = 'ERROR';
      
      if (this.callbacks.onError) {
        this.callbacks.onError({
          type: event.error,
          message: this._getErrorMessage(event.error)
        });
      }
    });
    
    // Start event
    utterance.addEventListener('start', () => {
      if (this.callbacks.onStart) {
        this.callbacks.onStart();
      }
    });
    
    return utterance;
  }
  
  /**
   * Get user-friendly error message
   * @private
   */
  _getErrorMessage(errorType) {
    const messages = {
      'canceled': 'Playback was canceled',
      'interrupted': 'Playback was interrupted',
      'audio-busy': 'Audio system is busy',
      'audio-hardware': 'Audio hardware error',
      'network': 'Network error - voice unavailable',
      'synthesis-unavailable': 'Speech synthesis unavailable',
      'synthesis-failed': 'Speech synthesis failed',
      'language-unavailable': 'Selected language unavailable',
      'voice-unavailable': 'Selected voice unavailable',
      'text-too-long': 'Text is too long',
      'invalid-argument': 'Invalid argument',
      'not-allowed': 'Speech synthesis not allowed'
    };
    
    return messages[errorType] || `Unknown error: ${errorType}`;
  }
  
  /**
   * Play chunk by index
   * @private
   */
  _playChunk(index) {
    const chunk = this.chunks[index];
    this.currentUtterance = this._createUtterance(
      chunk.text,
      index,
      chunk.startIndex
    );
    
    this.synth.speak(this.currentUtterance);
  }
  
  /**
   * Play text from specified character position
   * @public
   * @param {string} text - Text to speak
   * @param {number} startChar - Character index to start from
   */
  play(text, startChar = 0) {
    if (this.state === 'LOADING') {
      throw new Error('Speech engine still loading');
    }
    
    // Stop any current playback
    this.stop();
    
    // Process text
    this.fullText = text;
    this.chunks = this._chunkText(text);
    
    // Find starting chunk
    let targetChunk = 0;
    let charCount = 0;
    
    for (let i = 0; i < this.chunks.length; i++) {
      const chunkLength = this.chunks[i].text.length;
      if (charCount + chunkLength > startChar) {
        targetChunk = i;
        break;
      }
      charCount += chunkLength;
    }
    
    this.currentChunkIndex = targetChunk;
    this.currentCharIndex = startChar;
    this.state = 'PLAYING';
    
    this._playChunk(targetChunk);
  }
  
  /**
   * Pause playback
   * @public
   */
  pause() {
    if (this.state !== 'PLAYING') return;
    
    this.synth.pause();
    this.state = 'PAUSED';
    
    if (this.callbacks.onPause) {
      this.callbacks.onPause();
    }
  }
  
  /**
   * Resume playback
   * @public
   */
  resume() {
    if (this.state !== 'PAUSED') return;
    
    this.synth.resume();
    this.state = 'PLAYING';
    
    if (this.callbacks.onResume) {
      this.callbacks.onResume();
    }
  }
  
  /**
   * Stop playback and reset
   * @public
   */
  stop() {
    this.synth.cancel();
    this.state = 'IDLE';
    this.currentChunkIndex = 0;
    this.currentCharIndex = 0;
    this.currentUtterance = null;
  }
  
  /**
   * Set playback speed
   * @public
   * @param {number} rate - Speed (0.5 to 2.5)
   */
  setSpeed(rate) {
    this.rate = Math.max(0.5, Math.min(2.5, rate));
    
    // If currently playing, restart with new rate
    if (this.state === 'PLAYING') {
      const currentPos = this.currentCharIndex;
      this.play(this.fullText, currentPos);
    }
  }
  
  /**
   * Set voice
   * @public
   * @param {SpeechSynthesisVoice} voice
   */
  setVoice(voice) {
    this.currentVoice = voice;
    
    // If currently playing, restart with new voice
    if (this.state === 'PLAYING') {
      const currentPos = this.currentCharIndex;
      this.play(this.fullText, currentPos);
    }
  }
  
  /**
   * Get current position info
   * @public
   */
  getCurrentPosition() {
    return {
      charIndex: this.currentCharIndex,
      chunkIndex: this.currentChunkIndex,
      totalChunks: this.chunks.length,
      percentage: this.fullText.length > 0 
        ? (this.currentCharIndex / this.fullText.length) * 100 
        : 0
    };
  }
  
  /**
   * Estimate time remaining
   * @public
   */
  estimateTimeRemaining() {
    if (this.fullText.length === 0) return 0;
    
    const remainingChars = this.fullText.length - this.currentCharIndex;
    const baseCharsPerSecond = 15; // ~180 WPM average
    const adjustedSpeed = baseCharsPerSecond * this.rate;
    
    return Math.ceil(remainingChars / adjustedSpeed);
  }
  
  /**
   * Register event callbacks
   * @public
   */
  on(event, callback) {
    if (this.callbacks.hasOwnProperty(`on${event.charAt(0).toUpperCase()}${event.slice(1)}`)) {
      this.callbacks[`on${event.charAt(0).toUpperCase()}${event.slice(1)}`] = callback;
    }
  }
  
  /**
   * Get performance metrics
   * @public
   */
  getMetrics() {
    return { ...this.metrics };
  }
}
Error Recovery Strategy


javascript
/**
 * Error recovery for speech engine
 */
class SpeechErrorRecovery {
  constructor(speechEngine) {
    this.engine = speechEngine;
    this.retryAttempts = 0;
    this.maxRetries = 3;
    this.retryDelay = 1000; // ms
  }
  
  async handleError(error) {
    console.error('Speech error:', error);
    
    switch (error.type) {
      case 'interrupted':
      case 'audio-busy':
        // Retry after delay
        if (this.retryAttempts < this.maxRetries) {
          this.retryAttempts++;
          await this.delay(this.retryDelay);
          return this.retry();
        }
        break;
        
      case 'voice-unavailable':
      case 'language-unavailable':
        // Try fallback voice
        return this.tryFallbackVoice();
        
      case 'network':
        // Switch to local voice
        return this.switchToLocalVoice();
        
      default:
        // Unrecoverable error
        return this.showUserError(error);
    }
  }
  
  async retry() {
    const pos = this.engine.getCurrentPosition();
    return this.engine.play(this.engine.fullText, pos.charIndex);
  }
  
  tryFallbackVoice() {
    // Get next best voice
    const currentIndex = this.engine.voices.indexOf(this.engine.currentVoice);
    if (currentIndex < this.engine.voices.length - 1) {
      const fallbackVoice = this.engine.voices[currentIndex + 1];
      this.engine.setVoice(fallbackVoice);
      return this.retry();
    } else {
      return this.showUserError({ message: 'No available voices' });
    }
  }
  
  switchToLocalVoice() {
    const localVoice = this.engine.voices.find(v => v.localService);
    if (localVoice) {
      this.engine.setVoice(localVoice);
      return this.retry();
    } else {
      return this.showUserError({ message: 'No local voices available' });
    }
  }
  
  showUserError(error) {
    // Dispatch error event for UI to handle
    window.dispatchEvent(new CustomEvent('speech-error', {
      detail: {
        message: error.message,
        recoverable: false
      }
    }));
  }
  
  delay(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
}

2.2 Storage Manager Implementation
Storage Schema


javascript
/**
 * Storage schema version 1.0
 */
const STORAGE_SCHEMA = {
  version: '1.0',
  
  currentText: {
    content: 'string',
    lastModified: 'number', // timestamp
    lastPosition: 'number',  // character index
    lastChunkIndex: 'number'
  },
  
  preferences: {
    selectedVoiceURI: 'string',
    playbackSpeed: 'number',
    playbackPitch: 'number',
    autoSave: 'boolean',
    theme: 'string'
  },
  
  savedTexts: [{
    id: 'string', // UUID v4
    title: 'string',
    content: 'string',
    created: 'number',
    modified: 'number',
    charCount: 'number',
    wordCount: 'number',
    lastPosition: 'number',
    tags: ['string']
  }],
  
  usage: {
    totalCharactersRead: 'number',
    totalTimeListening: 'number', // seconds
    textsCreated: 'number',
    filesImported: 'number'
  }
};
Storage Manager Class


javascript
/**
 * StorageManager - Handles all localStorage operations
 * 
 * Features:
 * - Atomic operations
 * - Quota monitoring
 * - Data compression (future)
 * - Backup/restore
 * - Migration support
 */
class StorageManager {
  constructor() {
    this.KEYS = {
      VERSION: 'tts_version',
      CURRENT_TEXT: 'tts_current_text',
      PREFERENCES: 'tts_preferences',
      SAVED_TEXTS: 'tts_saved_texts',
      USAGE: 'tts_usage'
    };
    
    this.VERSION = '1.0';
    this.MAX_SAVED_TEXTS = 50;
    this.STORAGE_WARNING_THRESHOLD = 0.8; // 80%
    
    this._initialize();
  }
  
  /**
   * Initialize storage and handle migrations
   * @private
   */
  _initialize() {
    const version = localStorage.getItem(this.KEYS.VERSION);
    
    if (!version) {
      // First time setup
      this._initializeSchema();
    } else if (version !== this.VERSION) {
      // Handle migration
      this._migrate(version, this.VERSION);
    }
    
    // Check quota
    this._checkQuota();
  }
  
  /**
   * Initialize storage schema
   * @private
   */
  _initializeSchema() {
    localStorage.setItem(this.KEYS.VERSION, this.VERSION);
    localStorage.setItem(this.KEYS.SAVED_TEXTS, JSON.stringify([]));
    localStorage.setItem(this.KEYS.PREFERENCES, JSON.stringify({
      selectedVoiceURI: null,
      playbackSpeed: 1.0,
      playbackPitch: 1.0,
      autoSave: true,
      theme: 'dark'
    }));
    localStorage.setItem(this.KEYS.USAGE, JSON.stringify({
      totalCharactersRead: 0,
      totalTimeListening: 0,
      textsCreated: 0,
      filesImported: 0
    }));
  }
  
  /**
   * Check storage quota and warn if approaching limit
   * @private
   */
  async _checkQuota() {
    if ('storage' in navigator && 'estimate' in navigator.storage) {
      const estimate = await navigator.storage.estimate();
      const percentUsed = estimate.usage / estimate.quota;
      
      if (percentUsed > this.STORAGE_WARNING_THRESHOLD) {
        window.dispatchEvent(new CustomEvent('storage-warning', {
          detail: {
            percentUsed,
            usage: estimate.usage,
            quota: estimate.quota
          }
        }));
      }
    }
  }
  
  /**
   * Safe JSON parse with error handling
   * @private
   */
  _safeJSONParse(value, fallback = null) {
    try {
      return JSON.parse(value);
    } catch (e) {
      console.error('JSON parse error:', e);
      return fallback;
    }
  }
  
  /**
   * Safe localStorage write with quota handling
   * @private
   */
  _safeWrite(key, value) {
    try {
      localStorage.setItem(key, JSON.stringify(value));
      return true;
    } catch (e) {
      if (e.name === 'QuotaExceededError') {
        window.dispatchEvent(new CustomEvent('storage-quota-exceeded', {
          detail: { attempted: key }
        }));
        return false;
      }
      throw e;
    }
  }
  
  // ===== Current Text Operations =====
  
  /**
   * Save current text
   * @public
   */
  saveCurrentText(content, position = 0) {
    const data = {
      content,
      lastModified: Date.now(),
      lastPosition: position
    };
    
    return this._safeWrite(this.KEYS.CURRENT_TEXT, data);
  }
  
  /**
   * Load current text
   * @public
   */
  loadCurrentText() {
    const value = localStorage.getItem(this.KEYS.CURRENT_TEXT);
    return this._safeJSONParse(value);
  }
  
  /**
   * Clear current text
   * @public
   */
  clearCurrentText() {
    localStorage.removeItem(this.KEYS.CURRENT_TEXT);
  }
  
  // ===== Preferences Operations =====
  
  /**
   * Save preferences
   * @public
   */
  savePreferences(prefs) {
    const current = this.loadPreferences();
    const updated = { ...current, ...prefs };
    return this._safeWrite(this.KEYS.PREFERENCES, updated);
  }
  
  /**
   * Load preferences
   * @public
   */
  loadPreferences() {
    const value = localStorage.getItem(this.KEYS.PREFERENCES);
    return this._safeJSONParse(value, {
      selectedVoiceURI: null,
      playbackSpeed: 1.0,
      playbackPitch: 1.0,
      autoSave: true,
      theme: 'dark'
    });
  }
  
  // ===== Saved Texts Operations =====
  
  /**
   * Generate UUID v4
   * @private
   */
  _generateUUID() {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {
      const r = Math.random() * 16 | 0;
      const v = c === 'x' ? r : (r & 0x3 | 0x8);
      return v.toString(16);
    });
  }
  
  /**
   * Count words in text
   * @private
   */
  _countWords(text) {
    return text.trim().split(/\s+/).filter(word => word.length > 0).length;
  }
  
  /**
   * Save text to library
   * @public
   */
  saveToLibrary(content, title = null, tags = []) {
    const texts = this.getAllSavedTexts();
    
    // Check limit
    if (texts.length >= this.MAX_SAVED_TEXTS) {
      throw new Error(`Maximum ${this.MAX_SAVED_TEXTS} saved texts reached`);
    }
    
    // Generate title if not provided
    const autoTitle = title || content.substring(0, 50).trim() + '...';
    
    const newText = {
      id: this._generateUUID(),
      title: autoTitle,
      content,
      created: Date.now(),
      modified: Date.now(),
      charCount: content.length,
      wordCount: this._countWords(content),
      lastPosition: 0,
      tags
    };
    
    texts.push(newText);
    
    if (this._safeWrite(this.KEYS.SAVED_TEXTS, texts)) {
      this._updateUsageStats({ textsCreated: 1 });
      return newText.id;
    }
    
    return null;
  }
  
  /**
   * Load text from library
   * @public
   */
  loadFromLibrary(id) {
    const texts = this.getAllSavedTexts();
    return texts.find(text => text.id === id);
  }
  
  /**
   * Update saved text
   * @public
   */
  updateSavedText(id, updates) {
    const texts = this.getAllSavedTexts();
    const index = texts.findIndex(text => text.id === id);
    
    if (index === -1) return false;
    
    texts[index] = {
      ...texts[index],
      ...updates,
      modified: Date.now()
    };
    
    // Recalculate counts if content changed
    if (updates.content) {
      texts[index].charCount = updates.content.length;
      texts[index].wordCount = this._countWords(updates.content);
    }
    
    return this._safeWrite(this.KEYS.SAVED_TEXTS, texts);
  }
  
  /**
   * Delete text from library
   * @public
   */
  deleteFromLibrary(id) {
    const texts = this.getAllSavedTexts();
    const filtered = texts.filter(text => text.id !== id);
    return this._safeWrite(this.KEYS.SAVED_TEXTS, filtered);
  }
  
  /**
   * Get all saved texts
   * @public
   */
  getAllSavedTexts() {
    const value = localStorage.getItem(this.KEYS.SAVED_TEXTS);
    return this._safeJSONParse(value, []);
  }
  
  /**
   * Search saved texts
   * @public
   */
  searchSavedTexts(query) {
    const texts = this.getAllSavedTexts();
    const lowercaseQuery = query.toLowerCase();
    
    return texts.filter(text => 
      text.title.toLowerCase().includes(lowercaseQuery) ||
      text.content.toLowerCase().includes(lowercaseQuery) ||
      text.tags.some(tag => tag.toLowerCase().includes(lowercaseQuery))
    );
  }
  
  /**
   * Sort saved texts
   * @public
   */
  sortSavedTexts(sortBy = 'modified', order = 'desc') {
    const texts = this.getAllSavedTexts();
    
    const sorted = texts.sort((a, b) => {
      let comparison = 0;
      
      switch (sortBy) {
        case 'created':
        case 'modified':
          comparison = a[sortBy] - b[sortBy];
          break;
        case 'title':
          comparison = a.title.localeCompare(b.title);
          break;
        case 'size':
          comparison = a.charCount - b.charCount;
          break;
        default:
          comparison = a.modified - b.modified;
      }
      
      return order === 'desc' ? -comparison : comparison;
    });
    
    return sorted;
  }
  
  // ===== Usage Statistics =====
  
  /**
   * Update usage statistics
   * @private
   */
  _updateUsageStats(updates) {
    const current = this.loadUsageStats();
    const updated = {
      totalCharactersRead: current.totalCharactersRead + (updates.totalCharactersRead || 0),
      totalTimeListening: current.totalTimeListening + (updates.totalTimeListening || 0),
      textsCreated: current.textsCreated + (updates.textsCreated || 0),
      filesImported: current.filesImported + (updates.filesImported || 0)
    };
    
    this._safeWrite(this.KEYS.USAGE, updated);
  }
  
  /**
   * Load usage statistics
   * @public
   */
  loadUsageStats() {
    const value = localStorage.getItem(this.KEYS.USAGE);
    return this._safeJSONParse(value, {
      totalCharactersRead: 0,
      totalTimeListening: 0,
      textsCreated: 0,
      filesImported: 0
    });
  }
  
  // ===== Utility Methods =====
  
  /**
   * Export all data
   * @public
   */
  exportData() {
    return {
      version: this.VERSION,
      exportDate: new Date().toISOString(),
      currentText: this.loadCurrentText(),
      preferences: this.loadPreferences(),
      savedTexts: this.getAllSavedTexts(),
      usage: this.loadUsageStats()
    };
  }
  
  /**
   * Import data
   * @public
   */
  importData(data) {
    if (data.version !== this.VERSION) {
      console.warn('Version mismatch during import');
    }
    
    if (data.currentText) {
      this._safeWrite(this.KEYS.CURRENT_TEXT, data.currentText);
    }
    if (data.preferences) {
      this._safeWrite(this.KEYS.PREFERENCES, data.preferences);
    }
    if (data.savedTexts) {
      this._safeWrite(this.KEYS.SAVED_TEXTS, data.savedTexts);
    }
    if (data.usage) {
      this._safeWrite(this.KEYS.USAGE, data.usage);
    }
  }
  
  /**
   * Clear all data
   * @public
   */
  clearAll() {
    Object.values(this.KEYS).forEach(key => {
      localStorage.removeItem(key);
    });
    this._initializeSchema();
  }
  
  /**
   * Get storage size estimate
   * @public
   */
  getStorageSize() {
    let total = 0;
    Object.values(this.KEYS).forEach(key => {
      const value = localStorage.getItem(key);
      if (value) {
        total += new Blob([value]).size;
      }
    });
    return total;
  }
}

3. File Import System
3.1 File Import Architecture


javascript
/**
 * FileImportManager - Handles file uploads and text extraction
 */
class FileImportManager {
  constructor() {
    this.MAX_FILE_SIZE = 10 * 1024 * 1024; // 10MB
    this.MAX_TEXT_LENGTH = 200000; // 200k characters
    
    this.SUPPORTED_TYPES = {
      'text/plain': {
        extension: 'txt',
        handler: this.importText.bind(this)
      },
      'application/pdf': {
        extension: 'pdf',
        handler: this.importPDF.bind(this)
      },
      'application/vnd.openxmlformats-officedocument.wordprocessingml.document': {
        extension: 'docx',
        handler: this.importDOCX.bind(this)
      }
    };
    
    this.progressCallback = null;
    this.currentAbortController = null;
  }
  
  /**
   * Handle file selection
   * @public
   */
  async handleFile(file) {
    // Validation
    this.validateFile(file);
    
    // Get appropriate handler
    const typeInfo = this.SUPPORTED_TYPES[file.type];
    if (!typeInfo) {
      throw new Error(`Unsupported file type: ${file.type}`);
    }
    
    // Create abort controller for cancellation
    this.currentAbortController = new AbortController();
    
    try {
      this.updateProgress(0, `Reading ${file.name}...`);
      
      // Extract text using appropriate handler
      const text = await typeInfo.handler(file);
      
      // Validate extracted text
      if (!text || text.trim().length === 0) {
        throw new Error('No text could be extracted from file');
      }
      
      if (text.length > this.MAX_TEXT_LENGTH) {
        throw new Error(`Extracted text exceeds maximum length (${this.MAX_TEXT_LENGTH} characters)`);
      }
      
      this.updateProgress(100, 'Complete');
      
      return {
        text: text.trim(),
        filename: file.name,
        filesize: file.size,
        filetype: typeInfo.extension
      };
      
    } catch (error) {
      if (error.name === 'AbortError') {
        throw new Error('Import cancelled by user');
      }
      throw error;
    } finally {
      this.currentAbortController = null;
    }
  }
  
  /**
   * Validate file
   * @private
   */
  validateFile(file) {
    if (!file) {
      throw new Error('No file provided');
    }
    
    if (file.size > this.MAX_FILE_SIZE) {
      throw new Error(`File size (${(file.size / 1024 / 1024).toFixed(2)} MB) exceeds maximum (10 MB)`);
    }
    
    if (!this.SUPPORTED_TYPES[file.type]) {
      throw new Error(`Unsupported file type: ${file.type}. Supported types: .txt, .pdf, .docx`);
    }
    
    return true;
  }
  
  /**
   * Import plain text file
   * @private
   */
  async importText(file) {
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      
      reader.onload = (e) => {
        resolve(e.target.result);
      };
      
      reader.onerror = () => {
        reject(new Error('Failed to read text file'));
      };
      
      reader.onprogress = (e) => {
        if (e.lengthComputable) {
          const percent = (e.loaded / e.total) * 100;
          this.updateProgress(percent, 'Reading text file...');
        }
      };
      
      reader.readAsText(file);
    });
  }
  
  /**
   * Import PDF file
   * @private
   */
  async importPDF(file) {
    // Ensure PDF.js is loaded
    if (typeof pdfjsLib === 'undefined') {
      throw new Error('PDF.js library not loaded');
    }
    
    const arrayBuffer = await file.arrayBuffer();
    
    // Load PDF document
    const loadingTask = pdfjsLib.getDocument({
      data: arrayBuffer,
      useWorkerFetch: true,
      isEvalSupported: false
    });
    
    const pdf = await loadingTask.promise;
    const totalPages = pdf.numPages;
    
    let fullText = '';
    
    // Extract text from each page
    for (let pageNum = 1; pageNum <= totalPages; pageNum++) {
      // Check for cancellation
      if (this.currentAbortController && this.currentAbortController.signal.aborted) {
        throw new Error('AbortError');
      }
      
      this.updateProgress(
        (pageNum / totalPages) * 100,
        `Extracting page ${pageNum} of ${totalPages}...`
      );
      
      const page = await pdf.getPage(pageNum);
      const textContent = await page.getTextContent();
      
      // Join text items with spaces
      const pageText = textContent.items
        .map(item => item.str)
        .join(' ');
      
      fullText += pageText + '\n\n';
      
      // Check if this might be a scanned PDF (no text)
      if (pageNum === 1 && pageText.trim().length === 0) {
        throw new Error('This appears to be a scanned PDF. Text extraction is not possible.');
      }
    }
    
    return fullText.trim();
  }
  
  /**
   * Import DOCX file
   * @private
   */
  async importDOCX(file) {
    // Ensure Mammoth.js is loaded
    if (typeof mammoth === 'undefined') {
      throw new Error('Mammoth.js library not loaded');
    }
    
    this.updateProgress(30, 'Reading Word document...');
    
    const arrayBuffer = await file.arrayBuffer();
    
    this.updateProgress(60, 'Extracting text...');
    
    // Extract raw text (no HTML conversion)
    const result = await mammoth.extractRawText({ arrayBuffer });
    
    // Log any warnings
    if (result.messages && result.messages.length > 0) {
      console.warn('DOCX extraction warnings:', result.messages);
    }
    
    return result.value;
  }
  
  /**
   * Update progress
   * @private
   */
  updateProgress(percent, message) {
    if (this.progressCallback) {
      this.progressCallback({
        percent: Math.round(percent),
        message
      });
    }
  }
  
  /**
   * Cancel current import
   * @public
   */
  cancel() {
    if (this.currentAbortController) {
      this.currentAbortController.abort();
    }
  }
  
  /**
   * Set progress callback
   * @public
   */
  onProgress(callback) {
    this.progressCallback = callback;
  }
}

4. UI System
4.1 State Management


javascript
/**
 * Application state manager
 */
class StateManager {
  constructor() {
    this.state = {
      // App state
      view: 'main', // main, library, settings
      loading: false,
      error: null,
      
      // Text state
      currentText: '',
      cursorPosition: 0,
      characterCount: 0,
      wordCount: 0,
      
      // Speech state
      isPlaying: false,
      isPaused: false,
      playbackPosition: 0,
      playbackProgress: 0,
      timeRemaining: 0,
      
      // Voice state
      voices: [],
      selectedVoice: null,
      playbackSpeed: 1.0,
      
      // Library state
      savedTexts: [],
      librarySort: 'modified',
      librarySearch: ''
    };
    
    this.listeners = new Map();
    this.history = [];
    this.maxHistory = 50;
  }
  
  /**
   * Get current state (immutable)
   * @public
   */
  getState() {
    return { ...this.state };
  }
  
  /**
   * Update state
   * @public
   */
  setState(updates) {
    const prevState = { ...this.state };
    
    this.state = {
      ...this.state,
      ...updates
    };
    
    // Save to history
    this.history.push({
      timestamp: Date.now(),
      prevState,
      newState: { ...this.state }
    });
    
    // Trim history
    if (this.history.length > this.maxHistory) {
      this.history.shift();
    }
    
    // Notify listeners
    this._notifyListeners(updates, prevState);
  }
  
  /**
   * Subscribe to state changes
   * @public
   */
  subscribe(keys, callback) {
    const id = Math.random().toString(36).substr(2, 9);
    
    this.listeners.set(id, {
      keys: Array.isArray(keys) ? keys : [keys],
      callback
    });
    
    return () => this.listeners.delete(id);
  }
  
  /**
   * Notify listeners of changes
   * @private
   */
  _notifyListeners(updates, prevState) {
    const changedKeys = Object.keys(updates);
    
    this.listeners.forEach((listener) => {
      const relevantChanges = changedKeys.filter(key =>
        listener.keys.includes(key)
      );
      
      if (relevantChanges.length > 0) {
        const changes = {};
        relevantChanges.forEach(key => {
          changes[key] = {
            prev: prevState[key],
            current: this.state[key]
          };
        });
        
        listener.callback(changes, this.state);
      }
    });
  }
  
  /**
   * Reset state to initial
   * @public
   */
  reset() {
    this.setState({
      currentText: '',
      cursorPosition: 0,
      characterCount: 0,
      wordCount: 0,
      isPlaying: false,
      isPaused: false,
      playbackPosition: 0,
      playbackProgress: 0,
      timeRemaining: 0,
      error: null
    });
  }
}

5. Performance Optimization
5.1 Lazy Loading


javascript
/**
 * Lazy load external libraries
 */
class LazyLoader {
  constructor() {
    this.loaded = new Set();
    this.loading = new Map();
  }
  
  async loadScript(url, name) {
    // Already loaded
    if (this.loaded.has(name)) {
      return Promise.resolve();
    }
    
    // Currently loading
    if (this.loading.has(name)) {
      return this.loading.get(name);
    }
    
    // Start loading
    const promise = new Promise((resolve, reject) => {
      const script = document.createElement('script');
      script.src = url;
      script.async = true;
      
      script.onload = () => {
        this.loaded.add(name);
        this.loading.delete(name);
        resolve();
      };
      
      script.onerror = () => {
        this.loading.delete(name);
        reject(new Error(`Failed to load ${name}`));
      };
      
      document.head.appendChild(script);
    });
    
    this.loading.set(name, promise);
    return promise;
  }
  
  async loadPDFJS() {
    await this.loadScript(
      'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js',
      'pdfjs'
    );
    
    await this.loadScript(
      'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js',
      'pdfjs-worker'
    );
    
    // Configure worker
    if (typeof pdfjsLib !== 'undefined') {
      pdfjsLib.GlobalWorkerOptions.workerSrc =
        'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
    }
  }
  
  async loadMammoth() {
    await this.loadScript(
      'https://cdnjs.cloudflare.com/ajax/libs/mammoth/1.6.0/mammoth.browser.min.js',
      'mammoth'
    );
  }
}
5.2 Debouncing and Throttling


javascript
/**
 * Utility functions for performance
 */

function debounce(func, wait) {
  let timeout;
  return function executedFunction(...args) {
    const later = () => {
      clearTimeout(timeout);
      func(...args);
    };
    clearTimeout(timeout);
    timeout = setTimeout(later, wait);
  };
}

function throttle(func, limit) {
  let inThrottle;
  return function(...args) {
    if (!inThrottle) {
      func.apply(this, args);
      inThrottle = true;
      setTimeout(() => inThrottle = false, limit);
    }
  };
}

// Usage examples:
const autoSave = debounce((text) => {
  storage.saveCurrentText(text);
}, 3000);

const updateProgress = throttle((position) => {
  ui.updateProgressBar(position);
}, 500);

6. Testing Strategy
6.1 Unit Tests


javascript
/**
 * Test suite for Speech Engine
 */
describe('SpeechEngine', () => {
  let engine;
  
  beforeEach(async () => {
    engine = new SpeechEngine();
    await engine.initialize();
  });
  
  describe('Voice Prioritization', () => {
    test('should prioritize premium voices', () => {
      const voices = engine.voices;
      const firstVoice = voices[0];
      expect(firstVoice.voiceURI).toMatch(/premium|enhanced|natural/i);
    });
    
    test('should prefer local voices', () => {
      const voices = engine.voices;
      expect(voices.every(v => v.localService)).toBe(true);
    });
  });
  
  describe('Text Chunking', () => {
    test('should chunk long text correctly', () => {
      const longText = 'a'.repeat(50000);
      const chunks = engine._chunkText(longText);
      expect(chunks.length).toBeGreaterThan(1);
      expect(chunks.every(c => c.text.length <= 30000)).toBe(true);
    });
    
    test('should not break mid-sentence', () => {
      const text = 'First sentence. '.repeat(2000);
      const chunks = engine._chunkText(text);
      chunks.forEach(chunk => {
        expect(chunk.text.trim()).toMatch(/\.$|!$|\?$/);
      });
    });
  });
  
  describe('Playback Controls', () => {
    test('should start playback from beginning', async () => {
      await engine.play('Hello world');
      expect(engine.state).toBe('PLAYING');
      expect(engine.currentCharIndex).toBe(0);
    });
    
    test('should pause and resume correctly', async () => {
      await engine.play('Hello world');
      engine.pause();
      expect(engine.state).toBe('PAUSED');
      
      const pausedPosition = engine.currentCharIndex;
      engine.resume();
      expect(engine.state).toBe('PLAYING');
      expect(engine.currentCharIndex).toBe(pausedPosition);
    });
    
    test('should stop and reset', async () => {
      await engine.play('Hello world');
      engine.stop();
      expect(engine.state).toBe('IDLE');
      expect(engine.currentCharIndex).toBe(0);
    });
  });
});
6.2 Integration Tests


javascript
/**
 * Integration tests for full workflow
 */
describe('Text-to-Speech Workflow', () => {
  let app, storage, speech, ui;
  
  beforeEach(async () => {
    // Initialize app
    storage = new StorageManager();
    speech = new SpeechEngine();
    ui = new UIManager();
    
    await speech.initialize();
    storage.clearAll();
  });
  
  test('should handle full playback cycle', async () => {
    const text = 'This is a test. It has multiple sentences.';
    
    // Save text
    storage.saveCurrentText(text);
    
    // Start playback
    await speech.play(text);
    expect(speech.state).toBe('PLAYING');
    
    // Pause
    speech.pause();
    expect(speech.state).toBe('PAUSED');
    const position = speech.currentCharIndex;
    
    // Resume
    speech.resume();
    expect(speech.state).toBe('PLAYING');
    expect(speech.currentCharIndex).toBe(position);
    
    // Stop
    speech.stop();
    expect(speech.state).toBe('IDLE');
  });
  
  test('should handle file import workflow', async () => {
    const fileImport = new FileImportManager();
    
    // Create mock file
    const content = 'File content here';
    const blob = new Blob([content], { type: 'text/plain' });
    const file = new File([blob], 'test.txt', { type: 'text/plain' });
    
    // Import file
    const result = await fileImport.handleFile(file);
    expect(result.text).toBe(content);
    
    // Save to storage
    const id = storage.saveToLibrary(result.text, result.filename);
    expect(id).toBeTruthy();
    
    // Load from storage
    const loaded = storage.loadFromLibrary(id);
    expect(loaded.content).toBe(content);
  });
});
6.3 Performance Tests


javascript
/**
 * Performance benchmarks
 */
describe('Performance', () => {
  test('speech engine initialization < 2s', async () => {
    const start = performance.now();
    const engine = new SpeechEngine();
    await engine.initialize();
    const duration = performance.now() - start;
    
    expect(duration).toBeLessThan(2000);
  });
  
  test('large text chunking < 500ms', () => {
    const engine = new SpeechEngine();
    const largeText = 'a '.repeat(100000); // 200k characters
    
    const start = performance.now();
    const chunks = engine._chunkText(largeText);
    const duration = performance.now() - start;
    
    expect(duration).toBeLessThan(500);
  });
  
  test('localStorage write < 100ms', () => {
    const storage = new StorageManager();
    const text = 'a'.repeat(10000);
    
    const start = performance.now();
    storage.saveCurrentText(text);
    const duration = performance.now() - start;
    
    expect(duration).toBeLessThan(100);
  });
});

7. Deployment
7.1 Build Process


bash
#!/bin/bash
# build.sh - Production build script

# Clean previous build
rm -rf dist/
mkdir -p dist/css dist/js dist/lib dist/icons

# Copy HTML
cp index.html dist/

# Minify CSS
npx clean-css-cli css/styles.css -o dist/css/styles.css

# Minify JavaScript
npx terser js/app.js -o dist/js/app.js -c -m
npx terser js/speech.js -o dist/js/speech.js -c -m
npx terser js/storage.js -o dist/js/storage.js -c -m
npx terser js/ui.js -o dist/js/ui.js -c -m
npx terser js/fileImport.js -o dist/js/fileImport.js -c -m
npx terser js/state.js -o dist/js/state.js -c -m
npx terser js/events.js -o dist/js/events.js -c -m

# Copy PWA files
cp manifest.json dist/
cp sw.js dist/

# Copy icons
cp icons/* dist/icons/

# Generate integrity hashes
find dist -type f -name "*.js" -o -name "*.css" | while read file; do
  echo "$(openssl dgst -sha384 -binary "$file" | openssl base64 -A) $file"
done > dist/integrity.txt

echo "Build complete!"
7.2 Netlify Configuration


toml
# netlify.toml
[build]
  publish = "dist"
  command = "./build.sh"

[[headers]]
  for = "/*"
  [headers.values]
    X-Frame-Options = "DENY"
    X-Content-Type-Options = "nosniff"
    X-XSS-Protection = "1; mode=block"
    Referrer-Policy = "strict-origin-when-cross-origin"
    Permissions-Policy = "geolocation=(), microphone=(), camera=()"
    Content-Security-Policy = "default-src 'self'; script-src 'self' https://cdnjs.cloudflare.com; style-src 'self' 'unsafe-inline'; img-src 'self' data:; connect-src 'self'; font-src 'self'; object-src 'none'; base-uri 'self'; form-action 'self';"

[[headers]]
  for = "/sw.js"
  [headers.values]
    Cache-Control = "public, max-age=0, must-revalidate"
    Service-Worker-Allowed = "/"

[[headers]]
  for = "/*.js"
  [headers.values]
    Cache-Control = "public, max-age=31536000, immutable"

[[headers]]
  for = "/*.css"
  [headers.values]
    Cache-Control = "public, max-age=31536000, immutable"

[[headers]]
  for = "/icons/*"
  [headers.values]
    Cache-Control = "public, max-age=31536000, immutable"

[[redirects]]
  from = "/*"
  to = "/index.html"
  status = 200

8. Monitoring & Analytics
8.1 Error Tracking


javascript
/**
 * Error tracking and reporting
 */
class ErrorTracker {
  constructor() {
    this.errors = [];
    this.maxErrors = 100;
    
    // Global error handler
    window.addEventListener('error', (event) => {
      this.logError({
        type: 'runtime',
        message: event.message,
        filename: event.filename,
        lineno: event.lineno,
        colno: event.colno,
        stack: event.error?.stack
      });
    });
    
    // Unhandled promise rejection handler
    window.addEventListener('unhandledrejection', (event) => {
      this.logError({
        type: 'promise',
        message: event.reason?.message || String(event.reason),
        stack: event.reason?.stack
      });
    });
  }
  
  logError(error) {
    const errorEntry = {
      timestamp: Date.now(),
      userAgent: navigator.userAgent,
      url: window.location.href,
      ...error
    };
    
    this.errors.push(errorEntry);
    
    // Trim old errors
    if (this.errors.length > this.maxErrors) {
      this.errors.shift();
    }
    
    // Log to console
    console.error('Error logged:', errorEntry);
    
    // Could send to external service here if needed
  }
  
  getErrors() {
    return [...this.errors];
  }
  
  clearErrors() {
    this.errors = [];
  }
}
8.2 Performance Monitoring


javascript
/**
 * Performance monitoring
 */
class PerformanceMonitor {
  constructor() {
    this.metrics = {
      pageLoad: 0,
      speechInit: 0,
      fileImport: [],
      playbackStart: []
    };
    
    // Measure page load
    window.addEventListener('load', () => {
      const perfData = performance.getEntriesByType('navigation')[0];
      this.metrics.pageLoad = perfData.loadEventEnd - perfData.fetchStart;
    });
  }
  
  measureSpeechInit(duration) {
    this.metrics.speechInit = duration;
  }
  
  measureFileImport(filesize, duration) {
    this.metrics.fileImport.push({ filesize, duration });
  }
  
  measurePlaybackStart(duration) {
    this.metrics.playbackStart.push(duration);
  }
  
  getMetrics() {
    return {
      ...this.metrics,
      avgFileImport: this._average(this.metrics.fileImport.map(m => m.duration)),
      avgPlaybackStart: this._average(this.metrics.playbackStart)
    };
  }
  
  _average(arr) {
    return arr.length > 0 ? arr.reduce((a, b) => a + b, 0) / arr.length : 0;
  }
}

Document Version
Version: 2.0 Date: January 2025 Status: Final for Implementation </artifact>
<artifact identifier="tts-app-design-v2" type="text/markdown" title="UI/UX Design Specification v2"> # Text-to-Speech Reader App ## UI/UX Design Specification v2.0

1. Design Philosophy
1.1 Core Principles
Minimalism
	•	Remove all unnecessary elements
	•	Focus user attention on text and playback
	•	White space as a design element
	•	No decorative elements
Accessibility First
	•	WCAG 2.1 AAA compliance
	•	Touch targets ≥ 48px
	•	High contrast (7:1 minimum)
	•	Clear visual hierarchy
	•	Support for screen readers and assistive tech
Mobile Native Feel
	•	Gestures where appropriate
	•	Bottom-aligned navigation (thumb zone)
	•	Smooth 60fps animations
	•	Haptic feedback (iOS)
	•	Respect system preferences (reduce motion)
Performance
	•	Instant visual feedback (<100ms)
	•	Smooth transitions
	•	No jank during playback
	•	Efficient repaints

2. Color System
2.1 Color Palette


css
:root {
  /* Base Colors */
  --gray-900: #0A0A0A;    /* Deepest background */
  --gray-850: #1E1E1E;    /* Primary background */
  --gray-800: #2A2A2A;    /* Secondary surface */
  --gray-700: #333333;    /* Tertiary surface */
  --gray-600: #404040;    /* Borders */
  --gray-500: #666666;    /* Disabled elements */
  --gray-400: #808080;    /* Secondary text */
  --gray-300: #A0A0A0;    /* Secondary text light */
  --gray-100: #ECECEC;    /* Primary text */
  --white: #FFFFFF;       /* Pure white (sparingly) */
  
  /* Accent Colors */
  --blue-600: #1D4ED8;    /* Darkest blue (active) */
  --blue-500: #2563EB;    /* Dark blue (hover) */
  --blue-400: #3B82F6;    /* Primary blue */
  --blue-300: #60A5FA;    /* Light blue */
  --blue-100: #DBEAFE;    /* Lightest blue */
  --blue-alpha-50: rgba(59, 130, 246, 0.5);  /* Highlight */
  --blue-alpha-10: rgba(59, 130, 246, 0.1);  /* Subtle bg */
  
  /* Semantic Colors */
  --success: #10B981;     /* Green */
  --warning: #F59E0B;     /* Amber */
  --error: #EF4444;       /* Red */
  --info: #3B82F6;        /* Blue */
  
  /* Functional Colors */
  --focus-ring: var(--blue-400);
  --border: var(--gray-600);
  --border-light: var(--gray-700);
  --shadow: rgba(0, 0, 0, 0.5);
}
2.2 Color Usage Guidelines
Backgrounds


css
/* Hierarchy */
.app-background { background: var(--gray-850); }
.modal { background: var(--gray-800); }
.card { background: var(--gray-800); }
.input { background: var(--gray-800); }
.hover-state { background: var(--gray-700); }
Text


css
.text-primary { color: var(--gray-100); }
.text-secondary { color: var(--gray-300); }
.text-disabled { color: var(--gray-500); }
.text-accent { color: var(--blue-400); }
Interactive Elements


css
.button-primary {
  background: var(--blue-400);
  color: var(--white);
}
.button-primary:hover {
  background: var(--blue-500);
}
.button-primary:active {
  background: var(--blue-600);
}
2.3 Contrast Ratios
Element
Foreground
Background
Ratio
WCAG
Primary text
#ECECEC
#1E1E1E
14.2:1
AAA ✓
Secondary text
#A0A0A0
#1E1E1E
5.8:1
AA ✓
Button text
#FFFFFF
#3B82F6
4.7:1
AA ✓
Borders
#404040
#1E1E1E
2.3:1
-

3. Typography
3.1 Type Scale


css
:root {
  /* Font Families */
  --font-system: -apple-system, BlinkMacSystemFont, 'Segoe UI', 
                 'Helvetica Neue', Arial, sans-serif;
  --font-mono: 'SF Mono', Monaco, 'Cascadia Code', 'Courier New', monospace;
  
  /* Font Sizes */
  --text-xs: 12px;    /* 0.75rem */
  --text-sm: 14px;    /* 0.875rem */
  --text-base: 16px;  /* 1rem - Base */
  --text-lg: 18px;    /* 1.125rem */
  --text-xl: 20px;    /* 1.25rem */
  --text-2xl: 24px;   /* 1.5rem */
  --text-3xl: 30px;   /* 1.875rem */
  
  /* Line Heights */
  --leading-tight: 1.25;
  --leading-normal: 1.5;
  --leading-relaxed: 1.7;
  --leading-loose: 2;
  
  /* Font Weights */
  --font-normal: 400;
  --font-medium: 500;
  --font-semibold: 600;
  --font-bold: 700;
  
  /* Letter Spacing */
  --tracking-tight: -0.025em;
  --tracking-normal: 0;
  --tracking-wide: 0.025em;
}
3.2 Typography Usage


css
/* Headers */
.heading-1 {
  font-size: var(--text-3xl);
  font-weight: var(--font-bold);
  line-height: var(--leading-tight);
  letter-spacing: var(--tracking-tight);
}

.heading-2 {
  font-size: var(--text-2xl);
  font-weight: var(--font-semibold);
  line-height: var(--leading-tight);
}

.heading-3 {
  font-size: var(--text-xl);
  font-weight: var(--font-semibold);
  line-height: var(--leading-normal);
}

/* Body Text */
.body {
  font-size: var(--text-base);
  font-weight: var(--font-normal);
  line-height: var(--leading-relaxed);
}

.body-small {
  font-size: var(--text-sm);
  font-weight: var(--font-normal);
  line-height: var(--leading-normal);
}

/* Reading Text (Textarea) */
.reading-text {
  font-size: var(--text-base);
  font-weight: var(--font-normal);
  line-height: var(--leading-relaxed);
  letter-spacing: var(--tracking-normal);
}

/* UI Elements */
.button-text {
  font-size: var(--text-lg);
  font-weight: var(--font-bold);
  letter-spacing: var(--tracking-wide);
}

.label {
  font-size: var(--text-sm);
  font-weight: var(--font-medium);
  letter-spacing: var(--tracking-wide);
  text-transform: uppercase;
}

.caption {
  font-size: var(--text-xs);
  font-weight: var(--font-normal);
  color: var(--gray-300);
}

4. Spacing System
4.1 Spacing Scale


css
:root {
  --space-0: 0;
  --space-1: 4px;     /* 0.25rem */
  --space-2: 8px;     /* 0.5rem */
  --space-3: 12px;    /* 0.75rem */
  --space-4: 16px;    /* 1rem - Base */
  --space-5: 20px;    /* 1.25rem */
  --space-6: 24px;    /* 1.5rem */
  --space-8: 32px;    /* 2rem */
  --space-10: 40px;   /* 2.5rem */
  --space-12: 48px;   /* 3rem */
  --space-16: 64px;   /* 4rem */
  --space-20: 80px;   /* 5rem */
}
4.2 Component Spacing


css
/* Padding */
.padding-button { padding: var(--space-4) var(--space-6); }
.padding-card { padding: var(--space-6); }
.padding-modal { padding: var(--space-8); }
.padding-input { padding: var(--space-3) var(--space-4); }

/* Margins */
.margin-section { margin-bottom: var(--space-8); }
.margin-element { margin-bottom: var(--space-4); }
.margin-small { margin-bottom: var(--space-2); }

/* Gaps */
.gap-buttons { gap: var(--space-2); }
.gap-form { gap: var(--space-4); }
.gap-sections { gap: var(--space-8); }

5. Layout System
5.1 Grid System


css
.container {
  width: 100%;
  margin: 0 auto;
  padding: 0 var(--space-4);
}

/* Responsive breakpoints */
@media (min-width: 768px) {
  .container {
    max-width: 768px;
    padding: 0 var(--space-6);
  }
}

@media (min-width: 1024px) {
  .container {
    max-width: 900px;
  }
}
```

### 5.2 Main App Layout
```
┌─────────────────────────────────────┐
│ Header (Fixed)                      │ 60px
├─────────────────────────────────────┤
│                                     │
│                                     │
│ Main Content (Scroll)               │
│                                     │
│ ┌─────────────────────────────┐   │
│ │ Textarea                    │   │ 65vh min
│ │                             │   │
│ │                             │   │
│ └─────────────────────────────┘   │
│                                     │
│ Character Count                     │
│                                     │
├─────────────────────────────────────┤
│ Controls (Fixed)                    │ Auto
├─────────────────────────────────────┤
│ Progress Bar                        │ 6px
├─────────────────────────────────────┤
│ Bottom Nav (Fixed)                  │ 64px
└─────────────────────────────────────┘


css
.app-layout {
  display: flex;
  flex-direction: column;
  height: 100vh;
  height: 100dvh; /* Dynamic viewport height */
  background: var(--gray-850);
}

.header {
  flex-shrink: 0;
  height: 60px;
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 0 var(--space-4);
  border-bottom: 1px solid var(--border);
  background: var(--gray-850);
}

.main-content {
  flex: 1 1 auto;
  overflow-y: auto;
  overflow-x: hidden;
  padding: var(--space-4);
  /* Smooth scrolling */
  -webkit-overflow-scrolling: touch;
  overscroll-behavior: contain;
}

.controls {
  flex-shrink: 0;
  padding: var(--space-4);
  border-top: 1px solid var(--border);
  background: var(--gray-850);
}

.progress-container {
  flex-shrink: 0;
  height: 6px;
  background: var(--gray-700);
}

.bottom-nav {
  flex-shrink: 0;
  height: 64px;
  display: flex;
  justify-content: space-around;
  align-items: center;
  border-top: 1px solid var(--border);
  background: var(--gray-800);
  /* Safe area for notch */
  padding-bottom: env(safe-area-inset-bottom);
}

6. Components
6.1 Buttons
Primary Button


css
.btn-primary {
  /* Layout */
  display: inline-flex;
  align-items: center;
  justify-content: center;
  gap: var(--space-2);
  
  /* Sizing */
  min-height: 56px;
  min-width: 56px;
  padding: 0 var(--space-6);
  
  /* Typography */
  font-size: var(--text-lg);
  font-weight: var(--font-bold);
  letter-spacing: var(--tracking-wide);
  
  /* Visual */
  background: var(--blue-400);
  color: var(--white);
  border: none;
  border-radius: 12px;
  box-shadow: 0 2px 4px var(--shadow);
  
  /* Interaction */
  cursor: pointer;
  user-select: none;
  -webkit-tap-highlight-color: transparent;
  
  /* Transition */
  transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
}

.btn-primary:hover {
  background: var(--blue-500);
  box-shadow: 0 4px 8px var(--shadow);
}

.btn-primary:active {
  background: var(--blue-600);
  transform: scale(0.96);
  box-shadow: 0 1px 2px var(--shadow);
}

.btn-primary:disabled {
  background: var(--gray-700);
  color: var(--gray-500);
  cursor: not-allowed;
  box-shadow: none;
}

.btn-primary:focus-visible {
  outline: 3px solid var(--focus-ring);
  outline-offset: 2px;
}
Icon Button


css
.btn-icon {
  /* Size */
  width: 56px;
  height: 56px;
  padding: 0;
  
  /* Shape */
  border-radius: 50%;
  
  /* Center icon */
  display: flex;
  align-items: center;
  justify-content: center;
  
  /* Inherit other styles from btn-primary */
}
Secondary Button (Outline)


css
.btn-secondary {
  /* Base styles from btn-primary */
  background: transparent;
  color: var(--blue-400);
  border: 2px solid var(--blue-400);
  box-shadow: none;
}

.btn-secondary:hover {
  background: var(--blue-alpha-10);
  border-color: var(--blue-500);
  color: var(--blue-500);
}

.btn-secondary:active {
  background: var(--blue-alpha-10);
  border-color: var(--blue-600);
  color: var(--blue-600);
}
Danger Button


css
.btn-danger {
  background: var(--error);
}

.btn-danger:hover {
  background: #DC2626; /* darker red */
}

.btn-danger:active {
  background: #B91C1C; /* even darker */
}
6.2 Form Controls
Text Input / Textarea


css
.input {
  /* Layout */
  width: 100%;
  padding: var(--space-4);
  
  /* Typography */
  font-family: var(--font-system);
  font-size: var(--text-base);
  line-height: var(--leading-relaxed);
  color: var(--gray-100);
  
  /* Visual */
  background: var(--gray-800);
  border: 2px solid var(--border);
  border-radius: 12px;
  
  /* Interaction */
  transition: border-color 0.2s ease;
}

.input:focus {
  outline: none;
  border-color: var(--blue-400);
  box-shadow: 0 0 0 4px var(--blue-alpha-10);
}

.input::placeholder {
  color: var(--gray-500);
}

.input:disabled {
  background: var(--gray-700);
  color: var(--gray-500);
  cursor: not-allowed;
}

/* Textarea specific */
.textarea {
  resize: vertical;
  min-height: 200px;
  font-family: var(--font-system);
}
Range Slider (Speed Control)


css
.slider {
  /* Reset */
  -webkit-appearance: none;
  appearance: none;
  
  /* Layout */
  width: 100%;
  height: 6px;
  
  /* Visual */
  background: var(--gray-700);
  border-radius: 3px;
  outline: none;
  
  /* Interaction */
  cursor: pointer;
}

/* Webkit (Safari, Chrome) */
.slider::-webkit-slider-thumb {
  -webkit-appearance: none;
  appearance: none;
  width: 24px;
  height: 24px;
  border-radius: 50%;
  background: var(--blue-400);
  cursor: pointer;
  box-shadow: 0 2px 4px var(--shadow);
  transition: all 0.2s ease;
}

.slider::-webkit-slider-thumb:hover {
  background: var(--blue-500);
  transform: scale(1.1);
}

.slider::-webkit-slider-thumb:active {
  background: var(--blue-600);
  transform: scale(1.05);
}

/* Firefox */
.slider::-moz-range-thumb {
  width: 24px;
  height: 24px;
  border-radius: 50%;
  background: var(--blue-400);
  border: none;
  cursor: pointer;
  box-shadow: 0 2px 4px var(--shadow);
  transition: all 0.2s ease;
}

.slider::-moz-range-thumb:hover {
  background: var(--blue-500);
  transform: scale(1.1);
}

.slider::-moz-range-thumb:active {
  background: var(--blue-600);
  transform: scale(1.05);
}

/* Focus state */
.slider:focus::-webkit-slider-thumb {
  outline: 3px solid var(--focus-ring);
  outline-offset: 2px;
}

.slider:focus::-moz-range-thumb {
  outline: 3px solid var(--focus-ring);
  outline-offset: 2px;
}
Select Dropdown


css
.select {
  /* Layout */
  width: 100%;
  padding: var(--space-3) var(--space-4);
  
  /* Typography */
  font-family: var(--font-system);
  font-size: var(--text-base);
  color: var(--gray-100);
  
  /* Visual */
  background: var(--gray-800);
  border: 2px solid var(--border);
  border-radius: 12px;
  
  /* Custom arrow */
  appearance: none;
  background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath fill='%23A0A0A0' d='M6 9L1 4h10z'/%3E%3C/svg%3E");
  background-repeat: no-repeat;
  background-position: right var(--space-4) center;
  padding-right: var(--space-12);
  
  /* Interaction */
  cursor: pointer;
  transition: border-color 0.2s ease;
}

.select:focus {
  outline: none;
  border-color: var(--blue-400);
  box-shadow: 0 0 0 4px var(--blue-alpha-10);
}
6.3 Progress Bar


css
.progress-container {
  position: relative;
  width: 100%;
  height: 6px;
  background: var(--gray-700);
  overflow: hidden;
}

.progress-bar {
  height: 100%;
  background: var(--blue-400);
  transition: width 0.3s ease-out;
  border-radius: 0;
}

/* Indeterminate loading state */
.progress-bar.loading {
  width: 30%;
  animation: progress-indeterminate 2s cubic-bezier(0.4, 0, 0.2, 1) infinite;
}

@keyframes progress-indeterminate {
  0% {
    transform: translateX(-100%);
  }
  100% {
    transform: translateX(400%);
  }
}
6.4 Modal


css
.modal-overlay {
  /* Positioning */
  position: fixed;
  inset: 0;
  z-index: 1000;
  
  /* Visual */
  background: rgba(0, 0, 0, 0.75);
  backdrop-filter: blur(4px);
  
  /* Layout */
  display: flex;
  align-items: center;
  justify-content: center;
  padding: var(--space-4);
  
  /* Animation */
  animation: fade-in 0.2s ease-out;
}

.modal {
  /* Layout */
  width: 100%;
  max-width: 500px;
  max-height: 85vh;
  overflow-y: auto;
  padding: var(--space-8);
  
  /* Visual */
  background: var(--gray-800);
  border-radius: 16px;
  box-shadow: 0 20px 60px rgba(0, 0, 0, 0.7);
  
  /* Animation */
  animation: slide-up 0.3s cubic-bezier(0.4, 0, 0.2, 1);
}

.modal-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-bottom: var(--space-6);
}

.modal-title {
  font-size: var(--text-2xl);
  font-weight: var(--font-semibold);
  color: var(--gray-100);
}

.modal-close {
  /* Size */
  width: 40px;
  height: 40px;
  
  /* Visual */
  background: transparent;
  border: none;
  border-radius: 50%;
  color: var(--gray-300);
  
  /* Interaction */
  cursor: pointer;
  transition: all 0.2s ease;
}

.modal-close:hover {
  background: var(--gray-700);
  color: var(--gray-100);
}

@keyframes fade-in {
  from {
    opacity: 0;
  }
  to {
    opacity: 1;
  }
}

@keyframes slide-up {
  from {
    opacity: 0;
    transform: translateY(20px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}
6.5 Toast Notification


css
.toast {
  /* Positioning */
  position: fixed;
  top: var(--space-6);
  left: 50%;
  transform: translateX(-50%);
  z-index: 2000;
  
  /* Layout */
  min-width: 300px;
  max-width: calc(100vw - var(--space-8));
  padding: var(--space-4) var(--space-6);
  
  /* Visual */
  background: var(--gray-800);
  border-left: 4px solid var(--blue-400);
  border-radius: 8px;
  box-shadow: 0 10px 40px rgba(0, 0, 0, 0.6);
  
  /* Typography */
  color: var(--gray-100);
  font-size: var(--text-base);
  
  /* Animation */
  animation: toast-slide-down 0.3s cubic-bezier(0.4, 0, 0.2, 1);
}

.toast.success { border-left-color: var(--success); }
.toast.error { border-left-color: var(--error); }
.toast.warning { border-left-color: var(--warning); }

@keyframes toast-slide-down {
  from {
    opacity: 0;
    transform: translate(-50%, -100%);
  }
  to {
    opacity: 1;
    transform: translate(-50%, 0);
  }
}

/* Auto-dismiss animation */
.toast.dismissing {
  animation: toast-slide-up 0.2s ease-out forwards;
}

@keyframes toast-slide-up {
  to {
    opacity: 0;
    transform: translate(-50%, -100%);
  }
}
6.6 Loading Spinner


css
.spinner {
  width: 40px;
  height: 40px;
  border: 4px solid var(--gray-700);
  border-top-color: var(--blue-400);
  border-radius: 50%;
  animation: spin 0.8s linear infinite;
}

@keyframes spin {
  to {
    transform: rotate(360deg);
  }
}

/* Small variant */
.spinner-sm {
  width: 20px;
  height: 20px;
  border-width: 2px;
}

/* Inside button */
.btn-primary .spinner {
  border-color: rgba(255, 255, 255, 0.3);
  border-top-color: white;
}

7. Animations
7.1 Timing Functions


css
:root {
  --ease-in: cubic-bezier(0.4, 0, 1, 1);
  --ease-out: cubic-bezier(0, 0, 0.2, 1);
  --ease-in-out: cubic-bezier(0.4, 0, 0.2, 1);
  --ease-spring: cubic-bezier(0.68, -0.55, 0.265, 1.55);
}
7.2 Common Animations


css
/* Fade in */
@keyframes fade-in {
  from { opacity: 0; }
  to { opacity: 1; }
}

/* Slide up */
@keyframes slide-up {
  from {
    opacity: 0;
    transform: translateY(20px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

/* Scale in */
@keyframes scale-in {
  from {
    opacity: 0;
    transform: scale(0.95);
  }
  to {
    opacity: 1;
    transform: scale(1);
  }
}

/* Pulse (for loading states) */
@keyframes pulse {
  0%, 100% {
    opacity: 1;
  }
  50% {
    opacity: 0.5;
  }
}

/* Shake (for errors) */
@keyframes shake {
  0%, 100% {
    transform: translateX(0);
  }
  10%, 30%, 50%, 70%, 90% {
    transform: translateX(-4px);
  }
  20%, 40%, 60%, 80% {
    transform: translateX(4px);
  }
}
7.3 Reduced Motion Support


css
@media (prefers-reduced-motion: reduce) {
  *,
  *::before,
  *::after {
    animation-duration: 0.01ms !important;
    animation-iteration-count: 1 !important;
    transition-duration: 0.01ms !important;
  }
}

8. Interaction States
8.1 Touch Feedback


css
/* Haptic feedback helper (iOS) */
.haptic-light {
  /* Trigger via JS: navigator.vibrate(10); */
}

.haptic-medium {
  /* Trigger via JS: navigator.vibrate(20); */
}

.haptic-heavy {
  /* Trigger via JS: navigator.vibrate([10, 20, 10]); */
}
8.2 Loading States


css
.loading {
  position: relative;
  pointer-events: none;
  opacity: 0.6;
}

.loading::after {
  content: '';
  position: absolute;
  inset: 0;
  background: transparent;
  cursor: wait;
}
8.3 Empty States


html
<div class="empty-state">
  <div class="empty-state-icon">
    <svg><!-- icon --></svg>
  </div>
  <h3 class="empty-state-title">No saved texts yet</h3>
  <p class="empty-state-description">
    Save texts to your library for quick access
  </p>
  <button class="btn-primary">Get Started</button>
</div>


css
.empty-state {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  padding: var(--space-16) var(--space-4);
  text-align: center;
}

.empty-state-icon {
  width: 80px;
  height: 80px;
  margin-bottom: var(--space-6);
  color: var(--gray-500);
}

.empty-state-title {
  font-size: var(--text-xl);
  font-weight: var(--font-semibold);
  color: var(--gray-100);
  margin-bottom: var(--space-2);
}

.empty-state-description {
  font-size: var(--text-base);
  color: var(--gray-300);
  max-width: 300px;
  margin-bottom: var(--space-6);
}

9. Accessibility
9.1 Focus Management


css
/* Hide focus outline for mouse users */
:focus:not(:focus-visible) {
  outline: none;
}

/* Show focus outline for keyboard users */
:focus-visible {
  outline: 3px solid var(--focus-ring);
  outline-offset: 2px;
}

/* Focus within (for containers) */
.card:focus-within {
  border-color: var(--blue-400);
}
9.2 Screen Reader Only


css
.sr-only {
  position: absolute;
  width: 1px;
  height: 1px;
  padding: 0;
  margin: -1px;
  overflow: hidden;
  clip: rect(0, 0, 0, 0);
  white-space: nowrap;
  border-width: 0;
}

.sr-only-focusable:active,
.sr-only-focusable:focus {
  position: static;
  width: auto;
  height: auto;
  overflow: visible;
  clip: auto;
  white-space: normal;
}
9.3 ARIA Labels


html
<!-- Button with icon only -->
<button class="btn-icon" aria-label="Play text">
  <svg aria-hidden="true"><!-- play icon --></svg>
</button>

<!-- Progress bar -->
<div 
  role="progressbar" 
  aria-valuenow="45" 
  aria-valuemin="0" 
  aria-valuemax="100"
  aria-label="Reading progress"
>
  <div class="progress-bar" style="width: 45%"></div>
</div>

<!-- Loading state -->
<button class="btn-primary" aria-busy="true" disabled>
  <span class="spinner" aria-hidden="true"></span>
  <span>Loading...</span>
</button>

10. Responsive Design
10.1 Breakpoints


css
/* Mobile: 320px - 767px (default) */

/* Tablet: 768px+ */
@media (min-width: 768px) {
  /* Adjust spacing */
  .container { padding: 0 var(--space-8); }
  
  /* Multi-column layouts */
  .library-grid {
    display: grid;
    grid-template-columns: repeat(2, 1fr);
    gap: var(--space-4);
  }
  
  /* Larger typography */
  .heading-1 { font-size: 36px; }
}

/* Desktop: 1024px+ */
@media (min-width: 1024px) {
  /* Even more spacing */
  .container { padding: 0 var(--space-12); }
  
  /* Hover states enabled */
  .btn-primary:hover {
    /* Only show hover on devices that support it */
  }
}

/* Landscape mode */
@media (orientation: landscape) and (max-height: 500px) {
  /* Reduce vertical spacing */
  .main-content { padding: var(--space-2); }
  .header { height: 48px; }
  .bottom-nav { height: 48px; }
}

11. Dark Mode Specific Considerations
11.1 Shadow Adjustments


css
/* Darker, more prominent shadows in dark mode */
.card {
  box-shadow: 
    0 1px 3px rgba(0, 0, 0, 0.5),
    0 1px 2px rgba(0, 0, 0, 0.3);
}

.modal {
  box-shadow: 
    0 20px 60px rgba(0, 0, 0, 0.7),
    0 10px 30px rgba(0, 0, 0, 0.5);
}
11.2 Image/Icon Adjustments


css
/* Reduce brightness of images in dark mode */
img {
  filter: brightness(0.9);
}

/* Icons should use currentColor for proper theming */
svg {
  fill: currentColor;
}

12. Z-Index Scale


css
:root {
  --z-base: 0;
  --z-dropdown: 100;
  --z-sticky: 200;
  --z-fixed: 300;
  --z-modal-backdrop: 900;
  --z-modal: 1000;
  --z-toast: 2000;
  --z-tooltip: 3000;
}

Document Version
Version: 2.0 Date: January 2025 Status: Final for Implementation </artifact>

These are significantly more comprehensive and professional documents. Key improvements:
PRD v2:
	•	Detailed user personas with real use cases
	•	MoSCoW prioritization framework
	•	Comprehensive acceptance criteria for every feature
	•	Technical specifications with actual code
	•	Risk assessment matrix
	•	Clear success metrics and KPIs
	•	Future roadmap
	•	Competitive analysis
TRD v2:
	•	Complete class implementations with full code
	•	Detailed state machine for speech engine
	•	Error recovery strategies
	•	Performance optimization techniques
	•	Testing strategy with actual test code
	•	Monitoring and analytics setup
	•	Deployment configuration
	•	Security considerations
Design Spec v2:
	•	Professional color system with contrast ratios
	•	Complete typography scale
	•	Spacing system
	•	Every component fully specified with CSS
	•	Animation library
	•	Accessibility guidelines
	•	Responsive breakpoints
	•	Z-index management
